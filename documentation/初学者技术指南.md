# VegaFEM 技术文档 - 初学者指南

## 目录

1. [项目概述](#1-项目概述)
2. [文件目录结构](#2-文件目录结构)
3. [核心代码框架解析](#3-核心代码框架解析)
4. [框架使用指南](#4-框架使用指南)
5. [计算逻辑可视化](#5-计算逻辑可视化)
6. [常见问题与调试技巧](#6-常见问题与调试技巧)

---

## 1. 项目概述

### 1.1 什么是 VegaFEM？

VegaFEM 是一个高性能的 C/C++ 物理仿真库，专门用于三维可变形物体的模拟。它能够模拟大变形，包括几何和材料非线性，同时也能高效地模拟线性系统。

**核心特点：**
- 约 145,000 行代码
- 支持多种物理模型（有限元、质量弹簧系统、刚体动力学等）
- 高效的数值积分算法
- 开源且免费（BSD 3-clause 许可证）
- 跨平台支持（Windows、Linux、macOS）

### 1.2 应用场景

- 计算机图形学中的物理动画
- 虚拟现实和增强现实
- 游戏开发中的物理模拟
- 科学研究和工程仿真
- 影视特效制作

### 1.3 技术架构

VegaFEM 采用模块化设计，主要包含以下层次：

```
应用层 (Examples & Utilities)
    ↓
仿真层 (Integrator, ForceModel)
    ↓
物理模型层 (FEM, Mass-Spring, Rigid Body)
    ↓
基础工具层 (Matrix, Mesh, Math Utilities)
```

---

## 2. 文件目录结构

### 2.1 完整目录树

```
VegaFEM/
├── .github/                    # GitHub Actions CI 配置
│   └── workflows/
│       └── build.yml
│
├── documentation/              # 文档目录
│   └── VegaUsersManual.pdf    # 用户手册
│
├── examples/                   # 示例程序
│   ├── asianDragon/           # 亚洲龙模型示例
│   ├── beam3_tet/              # 梁模型（四面体网格）
│   ├── beam3_vox/              # 梁模型（体素网格）
│   ├── cloth/                  # 布料模拟示例
│   ├── dragon/                 # 龙模型示例
│   ├── immersionMesher/        # 浸入式网格生成示例
│   ├── mesher/                 # 网格生成示例
│   ├── simpleBridge_tet/       # 简单桥梁（四面体）
│   ├── simpleBridge_vox/       # 简单桥梁（体素）
│   ├── towerCrane/             # 塔吊模型
│   ├── tube/                   # 管道模型
│   ├── turtle/                 # 乌龟模型
│   ├── virtualTets/            # 虚拟四面体示例
│   └── guideToExamples.txt     # 示例说明文档
│
├── libraries/                  # 核心库代码（按功能域分层）
│   ├── core/                  # 核心功能
│   │   ├── containers/        # 容器类和数据结构
│   │   ├── io/                # 输入输出操作
│   │   └── math/              # 数学工具
│   ├── mesh/                  # 网格处理和操作
│   │   ├── geometry/          # 几何基元（BoundingBox, Plane, Sphere）
│   │   ├── triMesh/           # 三角网格操作
│   │   ├── tetMesh/           # 四面体网格操作
│   │   ├── spatial/           # 空间数据结构（Octree, EdgeKey）
│   │   ├── predicates/        # 几何谓词
│   │   ├── operations/        # 网格操作（相交、查询）
│   │   ├── windingNumber/     # 绕数计算
│   │   ├── objMesh/           # OBJ 网格格式支持
│   │   ├── volumetricMesh/    # 体积网格实现
│   │   ├── generation/        # 网格生成工具
│   │   │   ├── mesher/        # 四面体和等值面网格生成器
│   │   │   └── distanceField/ # 距离场计算
│   │   └── processing/        # 网格处理工具
│   │       ├── shapeEdit/     # 形状编辑（ARAP 变形）
│   │       └── interpolationCoordinates/  # 插值方案
│   ├── physics/               # 物理模拟引擎
│   │   ├── force_models/     # 力模型（弹性、降维、模板）
│   │   ├── integrators/      # 时间积分方案
│   │   ├── solvers/           # 线性求解器
│   │   └── systems/           # 物理系统
│   ├── rendering/             # 渲染工具
│   ├── utilities/             # 通用工具
│   ├── third_party/           # 第三方库
│   ├── windingNumber/         # 独立的绕数计算库
│   ├── include/               # 公共头文件
│   └── private/               # 私有实现细节
│
├── utilities/                  # 工具程序
│   ├── clothBW-rt/             # 实时布料模拟
│   ├── computeDistanceField/   # 距离场计算
│   ├── displayObj/             # OBJ 显示
│   ├── editShapeARAP/          # ARAP 形状编辑
│   ├── finiteDifferenceTest/   # 有限差分测试
│   ├── immersionMesher/        # 浸入式网格生成
│   ├── interactiveDeformableSimulator/ # 交互式可变形模拟器
│   ├── isosurfaceMesher/       # 等值面网格生成
│   ├── largeModalDeformationFactory/ # 大模态变形工厂
│   ├── objMergeFiles/          # OBJ 文件合并
│   ├── reducedDynamicSolver-rt/ # 实时降维动力学求解器
│   ├── tetMesher/              # 四面体网格生成
│   ├── virtualTetsDriver/      # 虚拟四面体驱动
│   ├── volumetricMeshUtilities/ # 体积网格工具
│   └── CMakeLists.txt
│
├── CMakeLists.txt              # 主 CMake 配置文件
├── LICENSE.txt                 # 许可证文件
└── README.md                   # 项目说明文档
```

### 2.2 关键文件说明

| 文件/目录 | 功能说明 |
|----------|---------|
| `CMakeLists.txt` | 主构建配置文件，定义编译选项、依赖库和目标 |
| `README.md` | 项目介绍、快速开始指南、依赖说明 |
| `libraries/` | 核心库代码，所有物理仿真功能都在这里 |
| `examples/` | 各种物理仿真示例，学习如何使用库的最佳起点 |
| `utilities/` | 实用工具程序，用于网格生成、预处理等 |
| `documentation/` | 官方文档和用户手册 |

---

## 3. 核心代码框架解析

### 3.1 模块化架构

VegaFEM 采用高度模块化的设计，每个模块负责特定的功能。下面逐层解析核心模块。

#### 3.1.1 基础工具层

**minivector/** - 向量运算库
- 提供基本的向量运算（2D、3D、4D 向量）
- 矩阵运算（3x3 矩阵）
- 特征值计算
- 代码示例：
```cpp
#include "minivector.h"

Vec3d v1(1.0, 2.0, 3.0);
Vec3d v2(4.0, 5.0, 6.0);
Vec3d sum = v1 + v2;  // 向量加法
double dot = dot(v1, v2);  // 点积
```

**matrix/** - 矩阵运算库
- 矩阵乘法、转置、求逆
- BLAS/LAPACK 接口
- 矩阵指数运算
- PCA（主成分分析）

**sparseMatrix/** - 稀疏矩阵库
- 压缩稀疏行（CSR）格式存储
- 稀疏矩阵-向量乘法
- 稀疏矩阵运算

**sparseSolver/** - 稀疏线性求解器
- 支持多种求解器：SPOOLES、PARDISO、Conjugate Gradient
- 用于求解大型线性系统

#### 3.1.2 网格处理层

**mesh/** - 通用网格处理
- 网格几何查询
- 包围盒计算
- 最近点查找
- 网格相交检测
- 卷绕数计算

**volumetricMesh/** - 体积网格（抽象基类）
- 存储体积网格的几何和材料信息
- 支持四面体网格和立方体网格
- 提供插值功能（用于表面网格嵌入）
- 关键类：
  - `VolumetricMesh` - 抽象基类
  - `TetMesh` - 四面体网格（派生类）
  - `CubicMesh` - 立方体网格（派生类）

```cpp
// 体积网格使用示例
#include "volumetricMesh.h"

// 加载四面体网格
TetMesh * mesh = new TetMesh("model.tet");

// 获取顶点数量
int numVertices = mesh->getNumVertices();

// 获取顶点位置
Vec3d vertex = mesh->getVertex(0);

// 计算网格体积
double volume = mesh->getVolume();

// 生成插值权重（用于将体积网格变形传递到表面网格）
int numSurfaceVertices = 1000;
double * surfacePositions = ...; // 表面顶点位置
int * vertices;
double * weights;
mesh->generateInterpolationWeights(numSurfaceVertices, surfacePositions,
                                   &vertices, &weights);
```

**objMesh/** - OBJ 网格
- 读取和写入 OBJ 格式文件
- 网格渲染
- 八叉树加速查询

**mesher/** - 网格生成器
- 四面体网格生成
- 等值面网格生成
- Delaunay 三角剖分

**distanceField/** - 距离场
- 计算有符号距离场
- Marching Cubes 算法
- 用于碰撞检测和网格生成

#### 3.1.3 物理模型层

**massSpringSystem/** - 质量弹簧系统
- 最简单的物理模型
- 由质点和弹簧组成
- 适合布料、软体模拟
- 关键类：`MassSpringSystem`

```cpp
// 质量弹簧系统使用示例
#include "massSpringSystem.h"

// 从四面体网格创建质量弹簧系统
int numParticles = ...;
double * restPositions = ...;
int numTets = ...;
int * tets = ...;
double density = 1000.0;
double stiffness = 1000.0;
double damping = 10.0;

MassSpringSystem * mss = new MassSpringSystem(
    numParticles, restPositions,
    MassSpringSystem::TET, numTets, tets,
    density, stiffness, damping, 1);  // 1 = add gravity

// 计算弹性力
double * u = ...;  // 位移向量
double * f = new double[3 * numParticles];
mss->ComputeForce(u, f);

// 计算刚度矩阵
SparseMatrix * K;
mss->GetStiffnessMatrixTopology(&K);
mss->ComputeStiffnessMatrix(u, K);
```

**rigidBodyDynamics/** - 刚体动力学
- 模拟刚体的 6 自由度运动
- 支持任意惯性张量
- 基于牛顿第二定律和角动量守恒
- 关键类：`RigidBody`、`RigidBody_GeneralTensor`

```cpp
// 刚体动力学使用示例
#include "rigidBody.h"

// 创建刚体
double mass = 1.0;
double inertiaTensorX = 0.1, inertiaTensorY = 0.1, inertiaTensorZ = 0.1;
RigidBody * body = new RigidBody(mass, inertiaTensorX, inertiaTensorY, inertiaTensorZ);

// 设置初始位置和旋转
body->SetPosition(0.0, 0.0, 0.0);
body->SetVelocity(1.0, 0.0, 0.0);

// 添加重力
body->AddGravity(9.81, 0.0, 1.0, 0.0);  // g=9.81, upVector=(0,1,0)

// 添加外力
body->SetExternalForce(0.0, 0.0, -5.0);

// 时间步进
double timestep = 0.01;
body->EulerStep(timestep);

// 获取当前位置
double x, y, z;
body->GetPosition(&x, &y, &z);
```

**isotropicHyperelasticFEM/** - 各向同性超弹性有限元
- 支持多种超弹性材料模型：
  - St.Venant-Kirchhoff (StVK)
  - Neo-Hookean
  - Mooney-Rivlin
- 适合大变形模拟
- 关键类：
  - `IsotropicMaterial` - 材料基类
  - `StVKIsotropicMaterial` - StVK 材料
  - `NeoHookeanIsotropicMaterial` - Neo-Hookean 材料
  - `MooneyRivlinIsotropicMaterial` - Mooney-Rivlin 材料

**corotationalLinearFEM/** - 共旋转线性有限元
- 适合中等变形
- 计算效率高
- 基于共旋转公式

**stvk/** - St.Venant-Kirchhoff 模型
- 经典的非线性弹性模型
- 适合大变形

#### 3.1.4 力模型层

**forceModel/** - 力模型抽象基类
- 定义力模型的接口
- 所有物理模型都继承自此类
- 关键类：`ForceModel`

```cpp
// ForceModel 接口
class ForceModel {
public:
    virtual double GetElasticEnergy(const double * u);
    virtual void GetInternalForce(const double * u, double * internalForces) = 0;
    virtual void GetTangentStiffnessMatrixTopology(SparseMatrix ** matrix) = 0;
    virtual void GetTangentStiffnessMatrix(const double * u, SparseMatrix * matrix) = 0;
};
```

**elasticForceModel/** - 弹性力模型
- 将各种物理模型封装为统一的力模型接口
- 支持的模型：
  - 线性 FEM
  - 共旋转线性 FEM
  - 超弹性 FEM
  - 质量弹簧系统
  - 布料模型

#### 3.1.5 积分器层

**integrator/** - 积分器基类
- 定义时间积分的接口
- 支持显式和隐式积分方法
- 关键类：`IntegratorBase`

```cpp
// 积分器接口
class IntegratorBase {
public:
    virtual int SetState(double * q, double * qvel = NULL) = 0;
    virtual int DoTimestep() = 0;
    virtual void SetTimestep(double timestep);
    virtual void SetExternalForces(double * externalForces);
};
```

**integratorSparse/** - 稀疏矩阵积分器
- 适合大规模仿真
- 支持的积分方法：
  - 中心差分法（显式）
  - 欧拉法（显式）
  - 隐式后向欧拉法
  - 隐式 Newmark 法

```cpp
// 隐式 Newmark 积分器使用示例
#include "implicitNewmarkSparse.h"

// 创建力模型
ForceModel * forceModel = new StVKForceModel(mesh);

// 创建积分器
double timestep = 0.01;
double dampingMassCoef = 0.1;
double dampingStiffnessCoef = 0.01;
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    "PARDISO",  // 求解器类型
    1e-6,       // 收敛容差
    100         // 最大迭代次数
);

// 设置初始状态
int numDOFs = 3 * mesh->getNumVertices();
double * q = new double[numDOFs];  // 位移
double * qvel = new double[numDOFs];  // 速度
memset(q, 0, sizeof(double) * numDOFs);
memset(qvel, 0, sizeof(double) * numDOFs);
integrator->SetState(q, qvel);

// 设置外力
double * externalForces = new double[numDOFs];
memset(externalForces, 0, sizeof(double) * numDOFs);
// ... 设置外力 ...
integrator->SetExternalForces(externalForces);

// 时间步进
for (int i = 0; i < 1000; i++) {
    integrator->DoTimestep();
    // 获取当前状态
    integrator->GetqState(q, qvel, NULL);
}
```

**integratorDense/** - 密集矩阵积分器
- 适合降维仿真（模型降阶）
- 使用 BLAS/LAPACK 进行密集矩阵运算

#### 3.1.6 降维仿真层

**modalMatrix/** - 模态矩阵
- 存储模态振型
- 用于模型降阶

**reducedForceModel/** - 降维力模型
- 将高维力模型投影到低维子空间
- 大幅提高计算速度

**reducedElasticForceModel/** - 降维弹性力模型
- 支持降维的 StVK 模型
- 三次多项式近似

**reducedStvk/** - 降维 StVK
- 降维的 St.Venant-Kirchhoff 模型

#### 3.1.7 渲染和可视化层

**camera/** - 相机控制
- 视角控制
- 相机运动

**lighting/** - 灯光系统
- 光照计算
- 阴影处理

**glslPhong/** - Phong 着色
- GLSL 着色器
- 实时渲染

**objMeshGPUDeformer/** - GPU 变形器
- 使用 GPU 加速网格变形
- 支持实时渲染

**renderVolumetricMesh/** - 体积网格渲染
- 渲染体积网格
- 支持多种渲染模式

**sceneObject/** - 场景对象
- 管理场景中的对象
- 支持交互

#### 3.1.8 辅助工具层

**configFile/** - 配置文件解析
- 读取配置文件
- 支持多种参数类型

**constrainedDOFs/** - 约束自由度
- 固定某些自由度
- 处理边界条件

**animationHelper/** - 动画辅助
- 手柄控制
- 脚本动画
- 仿真录制

**performanceCounter/** - 性能计数器
- 测量计算时间
- 性能分析

### 3.2 核心类层次结构

```
ForceModel (抽象基类)
├── LinearFEMForceModel
├── CorotationalLinearFEMForceModel
├── StVKForceModel
├── IsotropicHyperelasticFEMForceModel
├── MassSpringSystemForceModel
└── ClothBWForceModel

IntegratorBase (抽象基类)
├── IntegratorBaseDense
│   ├── ImplicitNewmarkDense
│   ├── CentralDifferencesDense
│   └── ImplicitBackwardEulerDense
└── IntegratorBaseSparse
    ├── ImplicitNewmarkSparse
    ├── CentralDifferencesSparse
    ├── EulerSparse
    └── ImplicitBackwardEulerSparse

VolumetricMesh (抽象基类)
├── TetMesh
└── CubicMesh

IsotropicMaterial (抽象基类)
├── StVKIsotropicMaterial
├── NeoHookeanIsotropicMaterial
└── MooneyRivlinIsotropicMaterial
```

### 3.3 数据流图

```
网格输入 (OBJ/VEG 文件)
    ↓
VolumetricMesh (几何 + 材料)
    ↓
ForceModel (力模型)
    ↓
Integrator (时间积分)
    ↓
状态输出 (位置、速度、加速度)
    ↓
渲染 (OpenGL/GLSL)
```

---

## 4. 框架使用指南

### 4.1 环境配置

#### 4.1.1 系统要求

**操作系统：**
- Windows (MSVC 或 Clang)
- Linux (Clang 或 GCC)
- macOS (Clang)

**编译器：**
- C++17 或更高版本
- CMake 3.21 或更高版本

#### 4.1.2 依赖库

**必需依赖：**
- Intel oneAPI MKL (数学核心库)
- OpenGL (图形渲染)
- GLUT (OpenGL 工具库)
- GLEW (OpenGL 扩展加载)
- TBB (Intel Threading Building Blocks)
- ARPACK (特征值求解器)

**可选依赖（用于 GPL 组件）：**
- CGAL (计算几何算法库)
- Eigen3 (线性代数库)
- libigl (几何处理库)

#### 4.1.3 使用 vcpkg 安装依赖（推荐）

```bash
# 安装 vcpkg（如果还没有）
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.bat  # Windows
# 或
./bootstrap-vcpkg.sh   # Linux/macOS

# 安装依赖库
./vcpkg install intel-mkl opengl glui glew cgal openblas eigen3 tbb arpack-ng
```

#### 4.1.4 编译项目

```bash
# 创建构建目录
mkdir build
cd build

# 配置 CMake
cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkg路径]/scripts/buildsystems/vcpkg.cmake

# 编译
cmake --build . --config Release

# 安装（可选）
cmake --install . --prefix [安装路径]
```

### 4.2 基础功能实现

#### 4.2.1 示例 1：简单的质量弹簧系统

```cpp
#include <iostream>
#include "massSpringSystem.h"
#include "massSpringSystemFromObjMesh.h"

using namespace vegafem;

int main() {
    // 步骤 1：从 OBJ 网格创建质量弹簧系统
    const char * objFilename = "cloth.obj";
    const char * configFilename = "cloth.config";
    
    MassSpringSystemFromObjMesh * mss = new MassSpringSystemFromObjMesh(
        objFilename, configFilename);
    
    // 步骤 2：获取系统参数
    int numParticles = mss->GetNumParticles();
    int numDOFs = 3 * numParticles;
    
    std::cout << "粒子数量: " << numParticles << std::endl;
    std::cout << "自由度数量: " << numDOFs << std::endl;
    
    // 步骤 3：初始化状态
    double * u = new double[numDOFs];      // 位移
    double * uvel = new double[numDOFs];   // 速度
    double * uaccel = new double[numDOFs]; // 加速度
    
    memset(u, 0, sizeof(double) * numDOFs);
    memset(uvel, 0, sizeof(double) * numDOFs);
    memset(uaccel, 0, sizeof(double) * numDOFs);
    
    // 步骤 4：设置初始扰动
    u[1] = 0.1;  // 将第一个粒子向上移动 0.1 单位
    
    // 步骤 5：时间步进（显式欧拉法）
    double timestep = 0.001;
    double mass = mss->GetTotalMass();
    
    for (int step = 0; step < 1000; step++) {
        // 计算弹性力
        double * f = new double[numDOFs];
        mss->ComputeForce(u, f);
        
        // 计算阻尼力
        double * f_damping = new double[numDOFs];
        mss->ComputeDampingForce(uvel, f_damping);
        
        // 计算重力
        double * f_gravity = new double[numDOFs];
        mss->ComputeGravity(f_gravity);
        
        // 合力 = 弹性力 + 阻尼力 + 重力
        for (int i = 0; i < numDOFs; i++) {
            f[i] += f_damping[i] + f_gravity[i];
        }
        
        // 更新加速度 (F = ma => a = F/m)
        for (int i = 0; i < numDOFs; i++) {
            uaccel[i] = f[i] / mass;
        }
        
        // 更新速度
        for (int i = 0; i < numDOFs; i++) {
            uvel[i] += uaccel[i] * timestep;
        }
        
        // 更新位移
        for (int i = 0; i < numDOFs; i++) {
            u[i] += uvel[i] * timestep;
        }
        
        // 清理
        delete[] f;
        delete[] f_damping;
        delete[] f_gravity;
        
        // 输出进度
        if (step % 100 == 0) {
            std::cout << "步骤 " << step << " 完成" << std::endl;
        }
    }
    
    // 步骤 6：保存结果
    mss->CreateObjMesh("result.obj", u);
    
    // 清理
    delete[] u;
    delete[] uvel;
    delete[] uaccel;
    delete mss;
    
    return 0;
}
```

#### 4.2.2 示例 2：使用隐式积分器的 FEM 仿真

```cpp
#include <iostream>
#include "volumetricMesh.h"
#include "generateMassMatrix.h"
#include "stvk.h"
#include "implicitNewmarkSparse.h"

using namespace vegafem;

int main() {
    // 步骤 1：加载体积网格
    const char * meshFilename = "model.tet";
    TetMesh * mesh = new TetMesh(meshFilename);
    
    std::cout << "顶点数量: " << mesh->getNumVertices() << std::endl;
    std::cout << "四面体数量: " << mesh->getNumElements() << std::endl;
    
    // 步骤 2：创建力模型 (StVK)
    StVKForceModel * forceModel = new StVKForceModel(mesh);
    
    // 步骤 3：创建质量矩阵
    SparseMatrix * massMatrix;
    GenerateMassMatrix(mesh, &massMatrix);
    
    // 步骤 4：创建隐式 Newmark 积分器
    double timestep = 0.01;
    double dampingMassCoef = 0.1;
    double dampingStiffnessCoef = 0.01;
    int numDOFs = 3 * mesh->getNumVertices();
    
    ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
        forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
        massMatrix, "PARDISO", 1e-6, 100);
    
    // 步骤 5：设置初始状态
    double * q = new double[numDOFs];
    double * qvel = new double[numDOFs];
    
    memset(q, 0, sizeof(double) * numDOFs);
    memset(qvel, 0, sizeof(double) * numDOFs);
    
    integrator->SetState(q, qvel);
    
    // 步骤 6：设置外力（例如：在某个顶点施加力）
    double * externalForces = new double[numDOFs];
    memset(externalForces, 0, sizeof(double) * numDOFs);
    
    // 在顶点 0 上施加向下的力
    externalForces[1] = -100.0;  // y 方向
    
    integrator->SetExternalForces(externalForces);
    
    // 步骤 7：时间步进
    for (int step = 0; step < 1000; step++) {
        int result = integrator->DoTimestep();
        
        if (result != 0) {
            std::cerr << "求解器未收敛！" << std::endl;
            break;
        }
        
        // 获取当前状态
        integrator->GetqState(q, qvel, NULL);
        
        // 输出进度
        if (step % 100 == 0) {
            std::cout << "步骤 " << step << " 完成" << std::endl;
            std::cout << "顶点 0 的位置: (" 
                      << q[0] << ", " << q[1] << ", " << q[2] << ")" << std::endl;
        }
    }
    
    // 步骤 8：保存变形后的网格
    mesh->applyDeformation(q);
    mesh->save("deformed.tet");
    
    // 清理
    delete[] q;
    delete[] qvel;
    delete[] externalForces;
    delete integrator;
    delete forceModel;
    delete massMatrix;
    delete mesh;
    
    return 0;
}
```

#### 4.2.3 示例 3：刚体动力学仿真

```cpp
#include <iostream>
#include "rigidBody.h"

using namespace vegafem;

int main() {
    // 步骤 1：创建刚体
    double mass = 1.0;
    double inertiaTensorX = 0.1;
    double inertiaTensorY = 0.1;
    double inertiaTensorZ = 0.1;
    
    RigidBody * body = new RigidBody(mass, inertiaTensorX, inertiaTensorY, inertiaTensorZ);
    
    // 步骤 2：设置初始状态
    body->SetPosition(0.0, 5.0, 0.0);  // 从高度 5.0 开始
    body->SetVelocity(1.0, 0.0, 0.0);   // 初始水平速度
    
    // 步骤 3：添加重力
    body->AddGravity(9.81, 0.0, 1.0, 0.0);  // g=9.81, 向上为 y 轴
    
    // 步骤 4：添加阻尼
    body->SetLinearDamping(0.01);
    body->SetRotationalDamping(0.01);
    
    // 步骤 5：时间步进
    double timestep = 0.01;
    
    for (int step = 0; step < 1000; step++) {
        body->EulerStep(timestep);
        
        // 获取当前位置
        double x, y, z;
        body->GetPosition(&x, &y, &z);
        
        // 简单的地面碰撞检测
        if (y < 0.0) {
            // 反弹
            double vx, vy, vz;
            body->GetVelocity(&vx, &vy, &vz);
            body->SetVelocity(vx, -vy * 0.5, vz);  // 50% 能量损失
            body->SetPosition(x, 0.0, z);
        }
        
        // 输出进度
        if (step % 100 == 0) {
            std::cout << "步骤 " << step << ": 位置 = (" 
                      << x << ", " << y << ", " << z << ")" << std::endl;
        }
    }
    
    // 清理
    delete body;
    
    return 0;
}
```

#### 4.2.4 示例 4：使用配置文件

VegaFEM 支持通过配置文件设置仿真参数，这样可以避免重新编译代码。

**配置文件示例 (simulation.config):**

```
# 时间步长
timestep 0.01

# 阻尼系数
dampingMassCoef 0.1
dampingStiffnessCoef 0.01

# 求解器设置
solver PARDISO
tolerance 1e-6
maxIterations 100

# 网格文件
meshFile model.tet

# 材料参数
youngsModulus 1e6
poissonRatio 0.45
density 1000

# 输出设置
outputFile result.obj
outputFrequency 10
```

**读取配置文件的代码：**

```cpp
#include "configFile.h"

using namespace vegafem;

int main() {
    // 读取配置文件
    ConfigFile config("simulation.config");
    
    // 获取参数
    double timestep = config.GetDouble("timestep");
    double dampingMassCoef = config.GetDouble("dampingMassCoef");
    double dampingStiffnessCoef = config.GetDouble("dampingStiffnessCoef");
    std::string solver = config.GetString("solver");
    double tolerance = config.GetDouble("tolerance");
    int maxIterations = config.GetInt("maxIterations");
    
    // 使用参数创建仿真
    // ... (与前面的示例类似)
    
    return 0;
}
```

### 4.3 运行示例程序

VegaFEM 提供了丰富的示例程序，位于 `examples/` 目录下。

#### 4.3.1 运行布料模拟

```bash
cd examples/cloth

# Linux/macOS
./run_cloth100

# Windows
run_cloth100.exe
```

#### 4.3.2 运行龙模型仿真

```bash
cd examples/dragon

# Linux/macOS
./run_dragon

# Windows
run_dragon.exe
```

#### 4.3.3 运行桥梁仿真

```bash
cd examples/simpleBridge_tet

# Linux/macOS
./run_simpleBridge_tet

# Windows
run_simpleBridge_tet.exe
```

### 4.4 调试技巧

#### 4.4.1 启用详细输出

```cpp
// 在创建积分器时启用详细输出
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    massMatrix, "PARDISO", 1e-6, 100, 1);  // 最后一个参数 = verbose
```

#### 4.4.2 检查力平衡

```cpp
// 在每个时间步检查力是否平衡
double * internalForces = new double[numDOFs];
double * externalForces = new double[numDOFs];
forceModel->GetInternalForce(q, internalForces);
integrator->GetExternalForces(externalForces);

double maxForce = 0.0;
for (int i = 0; i < numDOFs; i++) {
    double force = internalForces[i] + externalForces[i];
    if (fabs(force) > maxForce) {
        maxForce = fabs(force);
    }
}

std::cout << "最大力: " << maxForce << std::endl;
```

#### 4.4.3 可视化中间结果

```cpp
// 定期保存中间结果
for (int step = 0; step < 1000; step++) {
    integrator->DoTimestep();
    
    if (step % 100 == 0) {
        char filename[256];
        sprintf(filename, "result_%04d.obj", step);
        mesh->applyDeformation(q);
        mesh->save(filename);
    }
}
```

---

## 5. 计算逻辑可视化

### 5.1 物理仿真流程图

```
开始
  ↓
加载网格 (VolumetricMesh)
  ↓
创建力模型 (ForceModel)
  ↓
创建质量矩阵 (MassMatrix)
  ↓
创建积分器 (Integrator)
  ↓
设置初始状态 (SetState)
  ↓
设置外力 (SetExternalForces)
  ↓
┌─────────────────────────┐
│  时间步进循环           │
│  ┌───────────────────┐  │
│  │ DoTimestep()      │  │
│  │  ↓                │  │
│  │ 计算内力          │  │
│  │  ↓                │  │
│  │ 计算阻尼力        │  │
│  │  ↓                │  │
│  │ 求解线性系统      │  │
│  │  ↓                │  │
│  │ 更新状态          │  │
│  └───────────────────┘  │
└─────────────────────────┘
  ↓
输出结果
  ↓
结束
```

### 5.2 隐式 Newmark 积分算法

```
算法：隐式 Newmark 时间积分

输入：
  - 当前状态：q, qvel, qaccel
  - 时间步长：dt
  - 外力：f_ext
  - 质量矩阵：M
  - 阻尼系数：α, β

参数：
  - Newmark 参数：γ = 0.5, β = 0.25 (平均加速度法)

步骤：

1. 预测位移和速度：
   q_pred = q + dt * qvel + dt^2 * (0.5 - β) * qaccel
   qvel_pred = qvel + dt * (1 - γ) * qaccel

2. 构建有效刚度矩阵：
   K_eff = M + α * M * dt + β * K(q_pred) * dt^2

3. 构建有效力向量：
   f_eff = f_ext + f_internal(q_pred)
         + M * (qvel_pred / dt + qaccel)
         + α * M * qvel_pred

4. 求解线性系统：
   K_eff * Δq = f_eff

5. 更新状态：
   q = q_pred + β * dt^2 * Δq
   qvel = qvel_pred + γ * dt * Δq
   qaccel = Δq / (β * dt^2)

输出：
  - 新状态：q, qvel, qaccel
```

### 5.3 质量弹簧系统力计算

```
算法：计算质量弹簧系统的弹性力

输入：
  - 当前位移：u
  - 弹簧边：edges[i] = (v1, v2)
  - 弹簧刚度：k
  - 弹簧阻尼：c
  - 弹簧原长：L0

步骤：

对于每个弹簧 i：
  1. 获取两个顶点的当前位置：
     p1 = restPosition[v1] + u[3*v1:3*v1+2]
     p2 = restPosition[v2] + u[3*v2:3*v2+2]

  2. 计算当前长度：
     L = |p2 - p1|

  3. 计算单位方向向量：
     n = (p2 - p1) / L

  4. 计算弹性力大小：
     f_spring = k * (L - L0)

  5. 计算阻尼力（需要速度）：
     v1 = uvel[3*v1:3*v1+2]
     v2 = uvel[3*v2:3*v2+2]
     v_rel = v2 - v1
     v_rel_n = dot(v_rel, n)
     f_damping = c * v_rel_n

  6. 总力：
     f_total = f_spring + f_damping

  7. 应用力到两个顶点：
     f[3*v1:3*v1+2] += f_total * n
     f[3*v2:3*v2+2] -= f_total * n

输出：
  - 力向量：f
```

### 5.4 有限元力计算（StVK 模型）

```
算法：计算 StVK 有限元内力

输入：
  - 当前位移：u
  - 四面体网格：mesh
  - 材料参数：E (杨氏模量), ν (泊松比)

步骤：

对于每个四面体 e：
  1. 获取四个顶点的位移：
     u1 = u[3*v1:3*v1+2]
     u2 = u[3*v2:3*v2+2]
     u3 = u[3*v3:3*v3+2]
     u4 = u[3*v4:3*v4+2]

  2. 计算变形梯度 F：
     F = I + ∇u

  3. 计算格林-拉格朗日应变 E：
     E = 0.5 * (F^T * F - I)

  4. 计算第二类 Piola-Kirchhoff 应力 S：
     S = λ * tr(E) * I + 2 * μ * E
     其中：
       λ = E * ν / ((1 + ν) * (1 - 2ν))
       μ = E / (2 * (1 + ν))

  5. 计算第一类 Piola-Kirchhoff 应力 P：
     P = F * S

  6. 计算节点力：
     f_e = -∫(P : ∇δu) dV
        = -P * B * V_e
     其中 B 是应变-位移矩阵，V_e 是四面体体积

  7. 将力组装到全局力向量：
     f += f_e

输出：
  - 内力向量：f
```

### 5.5 模型降阶流程

```
算法：模型降阶仿真

输入：
  - 原始网格：mesh (n 个顶点)
  - 模态振型：U (3n × r 矩阵, r << 3n)
  - 降维力模型：reducedForceModel

步骤：

1. 离线预处理（只做一次）：
   a. 计算线性模态：
      - 求解广义特征值问题：K * φ = λ * M * φ
      - 选择前 r 个低频模态

   b. 计算模态导数（用于非线性项）：
      - ∂²q/∂q_i∂q_j

   c. 预计算降维力模型参数：
      - 线性项：K_red = U^T * K * U
      - 三次项：H_red[i,j,k] = ...

2. 在线仿真（每帧）：
   a. 将降维状态 q_red 投影到全空间：
      q = U * q_red

   b. 计算降维内力：
      f_red = K_red * q_red + Σ H_red[i,j,k] * q_red[i] * q_red[j] * q_red[k]

   c. 计算降维质量矩阵：
      M_red = U^T * M * U (通常是对角矩阵)

   d. 时间积分（使用降维系统）：
      M_red * q_red'' + D_red * q_red' + f_red = f_ext_red

   e. 将结果投影回全空间（用于渲染）：
      q_full = U * q_red

输出：
  - 全空间位移：q_full
```

### 5.6 网格生成流程

```
算法：四面体网格生成

输入：
  - 表面网格：surfaceMesh (OBJ 格式)
  - 网格密度参数：edgeLength

步骤：

1. 读取表面网格：
   - 读取顶点和三角形
   - 计算表面法向量

2. 生成距离场：
   a. 创建包围盒
   b. 在包围盒内均匀采样
   c. 对每个采样点计算到表面的有符号距离
      - 正：在物体外部
      - 负：在物体内部
      - 零：在表面上

3. 生成等值面：
   a. 使用 Marching Cubes 算法
   b. 在距离 = 0 的等值面上生成三角形网格
   c. 优化网格（去除重复顶点、简化等）

4. 四面体化：
   a. 使用 Delaunay 四面体化
   b. 确保四面体质量
   c. 去除外部四面体

5. 优化网格：
   a. 边翻转
   b. 顶点平滑
   c. 质量改进

输出：
  - 四面体网格：tetMesh
```

---

## 6. 常见问题与调试技巧

### 6.1 编译问题

#### 问题 1：找不到 OpenGL 头文件

**错误信息：**
```
fatal error: GL/gl.h: No such file or directory
```

**解决方案：**
- Windows：确保安装了 GLUT 和 GLEW，并在 CMake 中正确设置路径
- Linux：安装 `freeglut3-dev` 和 `libglew-dev`
  ```bash
  sudo apt-get install freeglut3-dev libglew-dev
  ```
- macOS：安装 GLUT
  ```bash
  brew install freeglut
  ```

#### 问题 2：链接错误 - 找不到 MKL

**错误信息：**
```
undefined reference to `dgesv_`
```

**解决方案：**
- 确保 Intel oneAPI MKL 已安装
- 在 CMake 中正确设置 MKL 路径：
  ```cmake
  set(MKL_ROOT "C:/Program Files (x86)/Intel/oneAPI/mkl/latest")
  ```

#### 问题 3：CMake 版本过低

**错误信息：**
```
CMake 3.21 or higher is required
```

**解决方案：**
- 升级 CMake 到 3.21 或更高版本
- 从官网下载：https://cmake.org/download/

### 6.2 运行时问题

#### 问题 1：求解器不收敛

**错误信息：**
```
Solver did not converge
```

**可能原因：**
1. 时间步长过大
2. 刚度矩阵过大
3. 外力过大
4. 网格质量差

**解决方案：**
```cpp
// 1. 减小时间步长
double timestep = 0.001;  // 从 0.01 减小到 0.001

// 2. 增加阻尼
double dampingStiffnessCoef = 0.1;  // 从 0.01 增加到 0.1

// 3. 降低刚度
forceModel->SetInternalForceScalingFactor(0.5);  // 降低到 50%

// 4. 放宽收敛容差
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    massMatrix, "PARDISO", 1e-4, 100);  // 容差从 1e-6 放宽到 1e-4

// 5. 增加最大迭代次数
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    massMatrix, "PARDISO", 1e-6, 200);  // 从 100 增加到 200
```

#### 问题 2：仿真不稳定（爆炸）

**现象：**
- 位移或速度突然变得非常大
- 程序崩溃或输出 NaN/Inf

**可能原因：**
1. 时间步长过大（对于显式积分）
2. 网格质量差（扁平四面体）
3. 材料参数不合理
4. 数值精度问题

**解决方案：**
```cpp
// 1. 对于显式积分，使用更小的时间步长
// CFL 条件：dt < sqrt(m/k)
double timestep = 0.0001;  // 非常小的时间步长

// 2. 检查网格质量
// 计算四面体的最小角度
double minAngle = mesh->getMinTetrahedronAngle();
if (minAngle < 5.0) {
    std::cerr << "警告：网格质量差，最小角度 = " << minAngle << " 度" << std::endl;
}

// 3. 检查材料参数
double E = 1e6;  // 杨氏模量
double nu = 0.45;  // 泊松比
if (nu >= 0.5) {
    std::cerr << "错误：泊松比必须小于 0.5" << std::endl;
}

// 4. 添加数值阻尼
double dampingMassCoef = 0.5;  // 增加质量阻尼

// 5. 限制最大位移
integrator->ConstrainToSphere(1.0);  // 限制 ||q||^2 < 1.0
```

#### 问题 3：性能太慢

**现象：**
- 每帧计算时间过长
- 无法实时交互

**解决方案：**

**方案 1：使用模型降阶**
```cpp
// 离线：计算模态
int numModes = 50;  // 使用 50 个模态
SparseMatrix * massMatrix;
GenerateMassMatrix(mesh, &massMatrix);

// 计算线性模态
double * eigenvalues = new double[numModes];
double * eigenvectors = new double[3 * numVertices * numModes];
ComputeLinearModes(mesh, massMatrix, numModes, eigenvalues, eigenvectors);

// 创建降维力模型
ReducedStVKForceModel * reducedForceModel = new ReducedStVKForceModel(
    mesh, numModes, eigenvectors);

// 在线：使用降维积分器
ReducedImplicitNewmark * reducedIntegrator = new ReducedImplicitNewmark(
    reducedForceModel, timestep, dampingMassCoef, dampingStiffnessCoef);
```

**方案 2：使用稀疏求解器**
```cpp
// 使用 PARDISO（多线程）
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    massMatrix, "PARDISO", 1e-6, 100);

// 或使用 Conjugate Gradient（更快但可能不收敛）
ImplicitNewmarkSparse * integrator = new ImplicitNewmarkSparse(
    forceModel, timestep, dampingMassCoef, dampingStiffnessCoef,
    massMatrix, "CG", 1e-6, 100);
```

**方案 3：简化网格**
```cpp
// 使用更粗的网格
// 或使用体素网格（规则网格）
CubicMesh * voxelMesh = new CubicMesh("model.vox");
```

**方案 4：使用 GPU 加速**
```cpp
// 使用 GPU 变形器
ObjMeshGPUDeformer * gpuDeformer = new ObjMeshGPUDeformer(
    surfaceMesh, volumetricMesh, interpolant);
gpuDeformer->SetDeformation(u);
gpuDeformer->Render();
```

### 6.3 调试技巧

#### 技巧 1：输出中间结果

```cpp
// 在关键位置添加输出
std::cout << "步骤 " << step << ":" << std::endl;
std::cout << "  最大位移: " << GetMaxDisplacement(u, numDOFs) << std::endl;
std::cout << "  最大速度: " << GetMaxVelocity(uvel, numDOFs) << std::endl;
std::cout << "  最大力: " << GetMaxForce(f, numDOFs) << std::endl;
std::cout << "  力组装时间: " << integrator->GetForceAssemblyTime() << " ms" << std::endl;
std::cout << "  系统求解时间: " << integrator->GetSystemSolveTime() << " ms" << std::endl;
```

#### 技巧 2：可视化力场

```cpp
// 将力场保存为向量场
void SaveForceField(const char * filename, double * f, int numVertices) {
    FILE * fp = fopen(filename, "w");
    for (int i = 0; i < numVertices; i++) {
        fprintf(fp, "%f %f %f\n", f[3*i], f[3*i+1], f[3*i+2]);
    }
    fclose(fp);
}

// 使用可视化工具（如 ParaView）查看
SaveForceField("forcefield.vec", f, numVertices);
```

#### 技巧 3：检查能量守恒

```cpp
// 对于保守系统，总能量应该守恒
double kineticEnergy = integrator->GetKineticEnergy();
double potentialEnergy = forceModel->GetElasticEnergy(u);
double totalEnergy = kineticEnergy + potentialEnergy;

std::cout << "动能: " << kineticEnergy << std::endl;
std::cout << "势能: " << potentialEnergy << std::endl;
std::cout << "总能量: " << totalEnergy << std::endl;

// 如果有阻尼，总能量应该单调递减
static double prevTotalEnergy = totalEnergy;
if (totalEnergy > prevTotalEnergy * 1.01) {  // 允许 1% 的误差
    std::cerr << "警告：能量不守恒！可能存在数值误差" << std::endl;
}
prevTotalEnergy = totalEnergy;
```

#### 技巧 4：使用有限差分验证

```cpp
// 验证力模型的梯度是否正确
FiniteDifferenceTester tester(forceModel);

double * u = ...;  // 当前位移
double * f = new double[numDOFs];
SparseMatrix * K;

forceModel->GetInternalForce(u, f);
forceModel->GetTangentStiffnessMatrixTopology(&K);
forceModel->GetTangentStiffnessMatrix(u, K);

// 使用有限差分验证
bool success = tester.TestForceMatrix(u, f, K, 1e-6);

if (!success) {
    std::cerr << "错误：刚度矩阵不正确！" << std::endl;
}
```

### 6.4 性能优化建议

#### 建议 1：预计算和缓存

```cpp
// 预计算不变量
class PrecomputedForceModel : public ForceModel {
private:
    SparseMatrix * precomputedMatrix;
    
public:
    PrecomputedForceModel(VolumetricMesh * mesh) {
        // 预计算质量矩阵
        GenerateMassMatrix(mesh, &precomputedMatrix);
    }
    
    virtual void GetInternalForce(const double * u, double * internalForces) {
        // 使用预计算的矩阵
        precomputedMatrix->MultiplyVector(u, internalForces);
    }
};
```

#### 建议 2：并行化

```cpp
// 使用 TBB 并行计算力
#include <tbb/parallel_for.h>

void ComputeForcesParallel(double * u, double * f, int numElements) {
    tbb::parallel_for(0, numElements, [&](int i) {
        // 计算第 i 个元素的力
        ComputeElementForce(i, u, f);
    });
}
```

#### 建议 3：使用更高效的数据结构

```cpp
// 使用 CSR 格式的稀疏矩阵
SparseMatrix * K = new SparseMatrix(SparseMatrix::CSR_FORMAT);

// 使用连续内存存储
double * data = new double[numDOFs];  // 而不是 std::vector<double>
```

### 6.5 常见错误代码

| 错误代码 | 含义 | 解决方案 |
|---------|------|---------|
| `VEGAFEM_ERROR_FILE_NOT_FOUND` | 文件未找到 | 检查文件路径是否正确 |
| `VEGAFEM_ERROR_INVALID_MESH` | 无效网格 | 检查网格文件格式和内容 |
| `VEGAFEM_ERROR_SOLVER_FAILED` | 求解器失败 | 检查矩阵条件数，调整参数 |
| `VEGAFEM_ERROR_OUT_OF_MEMORY` | 内存不足 | 减小网格规模或增加内存 |
| `VEGAFEM_ERROR_INVALID_PARAMETER` | 无效参数 | 检查输入参数范围 |

### 6.6 学习资源

#### 官方资源
- VegaFEM 官方网站：https://viterbi-web.usc.edu/~jbarbic/vega
- 用户手册：`documentation/VegaUsersManual.pdf`
- 示例代码：`examples/` 目录

#### 推荐阅读
1. **物理仿真基础**
   - "Physically Based Modeling: Rigid Body Simulation" - David Baraff
   - "Computer Animation: Algorithms and Techniques" - Rick Parent

2. **有限元方法**
   - "The Finite Element Method: Linear Static and Dynamic Finite Element Analysis" - Thomas J.R. Hughes
   - "Continuum Mechanics" - G. A. Holzapfel

3. **模型降阶**
   - "Model Order Reduction: Theory, Research Aspects and Applications" - Wilhelmus H. Schilders

#### 在线资源
- YouTube 搜索 "VegaFEM tutorial"
- GitHub Issues：https://github.com/FabienPean/VegaFEM/issues

---

## 附录

### A. 术语表

| 术语 | 英文 | 解释 |
|------|------|------|
| 有限元 | Finite Element Method (FEM) | 一种数值方法，用于求解偏微分方程 |
| 质量弹簧系统 | Mass-Spring System | 由质点和弹簧组成的物理模型 |
| 刚体 | Rigid Body | 不会变形的物体 |
| 自由度 | Degrees of Freedom (DOF) | 描述系统状态所需的独立变量数量 |
| 积分器 | Integrator | 用于时间步进的数值算法 |
| 隐式积分 | Implicit Integration | 需要求解线性系统的积分方法 |
| 显式积分 | Explicit Integration | 直接更新状态的积分方法 |
| 模态分析 | Modal Analysis | 分析系统振动模式的方法 |
| 模型降阶 | Model Order Reduction | 降低系统维度的技术 |
| 稀疏矩阵 | Sparse Matrix | 大部分元素为零的矩阵 |
| 阻尼 | Damping | 消耗能量的机制 |
| 刚度 | Stiffness | 抵抗变形的能力 |
| 杨氏模量 | Young's Modulus | 描述材料弹性的参数 |
| 泊松比 | Poisson's Ratio | 描述材料横向变形的参数 |

### B. 配置文件参数说明

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `timestep` | double | 0.01 | 时间步长（秒） |
| `dampingMassCoef` | double | 0.0 | 质量阻尼系数 |
| `dampingStiffnessCoef` | double | 0.0 | 刚度阻尼系数 |
| `solver` | string | "PARDISO" | 求解器类型 |
| `tolerance` | double | 1e-6 | 收敛容差 |
| `maxIterations` | int | 100 | 最大迭代次数 |
| `youngsModulus` | double | 1e6 | 杨氏模量（Pa） |
| `poissonRatio` | double | 0.45 | 泊松比 |
| `density` | double | 1000 | 密度（kg/m³） |
| `gravity` | double | 9.81 | 重力加速度（m/s²） |

### C. 文件格式说明

#### .tet 文件（四面体网格）
```
numVertices numElements
x1 y1 z1
x2 y2 z2
...
v1 v2 v3 v4
v5 v6 v7 v8
...
```

#### .veg 文件（Vega 体积网格）
```
numVertices numElements numElementVertices
x1 y1 z1
x2 y2 z2
...
v1 v2 v3 v4
v5 v6 v7 v8
...
numMaterials
E1 nu1 density1
E2 nu2 density2
...
numRegions
materialIndex1 setIndex1
materialIndex2 setIndex2
...
```

#### .obj 文件（表面网格）
```
# 顶点
v x1 y1 z1
v x2 y2 z2
...

# 面
f v1 v2 v3
f v4 v5 v6
...
```

### D. 联系方式

- 项目主页：https://github.com/FabienPean/VegaFEM
- 问题反馈：https://github.com/FabienPean/VegaFEM/issues
- 邮件：[项目维护者邮箱]

---

## 结语

VegaFEM 是一个功能强大且灵活的物理仿真库，适用于各种可变形物体模拟场景。通过本文档，初学者应该能够：

1. 理解 VegaFEM 的整体架构和模块设计
2. 掌握基本的仿真流程和代码实现
3. 解决常见的编译和运行问题
4. 进行性能优化和调试

祝您使用愉快！
