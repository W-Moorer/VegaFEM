# 符号距离场（SDF）在计算过程中的变化机制

## 概述

符号距离场（Signed Distance Field，SDF）是VegaFEM中用于碰撞检测和接触处理的核心数据结构。本文档详细说明SDF在计算过程中是如何产生变化的，包括初始化、计算、更新和与可变形对象的交互机制。

## 1. SDF的基本数据结构

### 1.1 数据存储

SDF的核心数据存储在`distanceData`数组中：

```cpp
float * distanceData; // 原始距离数据
```

距离场值在网格顶点(i,j,k)处的存储位置：

```cpp
distanceData[(k * (resolutionY + 1) + j) * (resolutionX + 1) + i]
```

其中：
- `resolutionX`, `resolutionY`, `resolutionZ`：各轴的分辨率
- `i, j, k`：网格顶点的索引，范围从0到resolutionX/Y/Z

### 1.2 边界框

SDF定义在一个边界框内：

```cpp
Vec3d bmin_; // 边界框的左下前角
Vec3d bmax_; // 边界框的右上后角
Vec3d side;  // 边界框的边长
double gridX, gridY, gridZ; // 网格单元的边长
double invGridX, invGridY, invGridZ; // 网格边长的倒数
```

## 2. SDF的初始化和计算过程

### 2.1 无符号距离场计算

无符号距离场通过`computeUnsignedField`函数计算：

```cpp
virtual int computeUnsignedField(ObjMesh * objMesh, int resolutionX, int resolutionY, int resolutionZ,
                                  int maxTriCount=15, int maxDepth=10, int zMin = -1, int zMax = -1);
```

**计算步骤：**

1. **网格预处理**
   ```cpp
   if (!(objMesh.isTriangularMesh())) {
       objMesh.triangulate();
   }
   ```

2. **构建八叉树加速结构**
   ```cpp
   ObjMeshOctree<TriangleWithCollisionInfo> * objMeshOctree =
       new ObjMeshOctree<TriangleWithCollisionInfo>(&objMesh, maxTriCount, maxDepth);
   ```

3. **初始化距离数据**
   ```cpp
   vegalong size = sizeof(float)*(resolutionX+1)*(resolutionY+1)*(zMax - zMin +1);
   distanceData = (float*) realloc (distanceData, size);
   
   // 初始化为FLT_MAX
   for(vegalong ii=0; ii<=resolutionX; ii++)
       for(vegalong jj=0; jj<=resolutionY; jj++)
           for(vegalong kk=zMin; kk<=zMax; kk++) {
               vegalong index = (kk-zMin) * (resolutionX+1) * (resolutionY+1) + jj * (resolutionX+1) + ii;
               distanceData[index] = FLT_MAX;
           }
   ```

4. **计算距离值**
   使用ZigZag算法遍历所有网格顶点，计算到最近三角形面的距离。

### 2.2 有符号距离场计算

有符号距离场通过`computeSignedField`或`computeFloodFillSignedField`函数计算：

```cpp
virtual int computeSignedField(ObjMesh * objMesh, int resolutionX, int resolutionY, int resolutionZ,
                                int maxTriCount=15, int maxDepth=10, int zMin = -1, int zMax = -1);

virtual int computeFloodFillSignedField(ObjMesh * objMesh, int resolutionX, int resolutionY, int resolutionZ,
                                         int maxTriCount=15, int maxDepth=10, int zMin = -1, int zMax = -1);
```

**计算步骤：**

1. **网格有效性检查**
   ```cpp
   // 检查网格是否为封闭流形
   if (objMeshOrientable->hasBoundary()) {
       cout << "Error: mesh has boundary. Signed distance field is ill-defined." << endl;
       return 1;
   }
   
   // 检查三角形方向是否一致
   if (numOrientationFlips != 0) {
       cout << "Error: triangles in the input mesh are not oriented consistently." << endl;
       return 2;
   }
   ```

2. **构建带伪法向量的八叉树**
   ```cpp
   ObjMeshOctree<TriangleWithCollisionInfoAndPseudoNormals> * objMeshOctree =
       new ObjMeshOctree<TriangleWithCollisionInfoAndPseudoNormals>(&objMesh, maxTriCount, maxDepth);
   ```

3. **计算有符号距离**
   - 对于网格外的点：距离为正值
   - 对于网格内的点：距离为负值
   - 使用伪法向量确定点的内外状态

### 2.3 多边形网格方法中的SDF计算

对于非流形网格，使用多边形网格方法计算SDF：

```cpp
// 1. 计算无符号距离场
code = field->computeUnsignedField(objMesh, resolutionX, resolutionY, resolutionZ, maxTriCount, maxDepth);

// 2. 计算等值面网格
ObjMesh * isoMesh = ComputeIsosurface(field, sigma);

// 3. 偏移距离场
field->offsetDistanceField(-sigma);

// 4. 使用洪水填充计算有符号距离场
code = field->computeFloodFillSignedField(isoMesh, resolutionX, resolutionY, resolutionZ, maxTriCount, maxDepth);

// 5. 恢复偏移
if (subtractSigma)
    field->offsetDistanceField(sigma);
```

## 3. SDF的变化机制

### 3.1 全局偏移（Global Offset）

`offsetDistanceField`函数对整个距离场进行统一的偏移：

```cpp
void DistanceField::offsetDistanceField(double offset)
{
    vegalong numGridPoints = (resolutionX+1) * (resolutionY+1) * (resolutionZ+1);
    
    printf("Applying offset %G to the distance field. Resolution is %d x %d x %d.\n",
           offset, resolutionX, resolutionY, resolutionZ);
    
    for(vegalong i=0; i<numGridPoints; i++)
        distanceData[i] += (float) offset;
}
```

**变化特点：**
- 对所有网格顶点的距离值同时加上相同的偏移量
- 时间复杂度：O(N)，其中N = (resolutionX+1)*(resolutionY+1)*(resolutionZ+1)
- 空间复杂度：O(1)，原地修改

**应用场景：**
- 多边形网格方法中调整等值面位置
- 创建膨胀或收缩的距离场
- 调整碰撞检测的容差

### 3.2 局部修改（Local Modification）

`setDistance`函数修改特定网格顶点的距离值：

```cpp
virtual inline void setDistance(int i, int j, int k, float value) {
    distanceData[(k * (resolutionY + 1) + j ) * (resolutionX + 1) + i] = value;
}
```

**变化特点：**
- 只修改单个网格顶点的距离值
- 时间复杂度：O(1)
- 空间复杂度：O(1)

**应用场景：**
- 调试和测试
- 特定区域的距离场修正
- 实现自定义的距离场修改算法

### 3.3 距离查询（Distance Query）

`distance`函数查询任意位置的距离值：

```cpp
virtual float distance(Vec3d pos, int constrainToBox=0) const
{
    // 获取包含pos的体素的左下后角顶点的索引坐标
    int i = (int)((pos[0] - bmin_[0]) * invGridX);
    int j = (int)((pos[1] - bmin_[1]) * invGridY);
    int k = (int)((pos[2] - bmin_[2]) * invGridZ);
    
    // 边界检查
    if (((i<0) || (i>=resolutionX) || (j<0) || (j>=resolutionY) || 
         (k<0) || (k>=resolutionZ)) && (!constrainToBox)) {
        printf("Warning: querying the distance field outside of the bounding box\n");
        return FLT_MAX;
    }
    
    // 约束到边界框内
    if (constrainToBox) {
        if (i >= resolutionX) { i = resolutionX - 1; pos[0] = bmax_[0]; }
        if (i < 0) { i = 0; pos[0] = bmin_[0]; }
        // ... 其他方向的约束
    }
    
    // 三线性插值计算距离
    return trilinearInterpolation(...);
}
```

**变化特点：**
- 不修改距离场数据，只进行查询
- 使用三线性插值获得连续的距离值
- 时间复杂度：O(1)

### 3.4 梯度计算（Gradient Computation）

`gradient`函数计算任意位置的距离场梯度：

```cpp
virtual Vec3d gradient(const Vec3d& pos)
{
    int i, j, k;
    
    // 获取索引
    i = (int)((pos[0] - bmin_[0]) * invGridX);
    j = (int)((pos[1] - bmin_[1]) * invGridY);
    k = (int)((pos[2] - bmin_[2]) * invGridZ);
    
    // 边界检查
    if ((i<=0) || (i>=resolutionX) || (j<=0) || (j>=resolutionY) || (k<=0) || (k>=resolutionZ)) {
        return Vec3d(0,0,0);
    }
    
    // 计算权重
    double wx, wy, wz;
    wx = ((pos[0]-bmin_[0]) / gridX) - i;
    wy = ((pos[1]-bmin_[1]) / gridY) - j;
    wz = ((pos[2]-bmin_[2]) / gridZ) - k;
    
    // 获取8个顶点的距离值
    float v000 = distance(i,j,k);
    float v100 = distance(i+1,j,k);
    float v110 = distance(i+1,j+1,k);
    float v010 = distance(i,j+1,k);
    float v001 = distance(i,j,k+1);
    float v101 = distance(i+1,j,k+1);
    float v111 = distance(i+1,j+1,k+1);
    float v011 = distance(i,j+1,k+1);
    
    // 计算梯度（基于三线性插值）
    return Vec3d(
        GRADIENT_COMPONENT_X(wx,wy,wz,v000,v100,v110,v010,v001,v101,v111,v011),
        GRADIENT_COMPONENT_Y(wx,wy,wz,v000,v100,v110,v010,v001,v101,v111,v011),
        GRADIENT_COMPONENT_Z(wx,wy,wz,v000,v100,v110,v010,v001,v101,v111,v011)
    );
}
```

**变化特点：**
- 梯度在单元边界处不连续
- 用于计算接触力的法向方向
- 时间复杂度：O(1)

## 4. SDF与可变形对象的交互

### 4.1 静态SDF + 动态对象

在VegaFEM中，SDF通常是**静态**的，在初始化时计算一次，然后在整个模拟过程中保持不变：

```cpp
// 初始化阶段：计算SDF
DistanceField * sdf = new DistanceField();
sdf->computeSignedField(collisionMesh, 256, 256, 256);

// 模拟循环：查询静态SDF
for (int i = 0; i < numVertices; i++) {
    Vec3d pos = currentPos[i];
    
    // 查询距离（SDF不变化）
    float d = sdf->distance(pos);
    
    if (d < 0) {
        // 检测到穿透，计算接触力
        Vec3d n = sdf->gradient(pos);
        n.normalize();
        Vec3d f_contact = penaltyStiffness * d * n;
        
        // 应用接触力
        f[3*i] += f_contact[0];
        f[3*i+1] += f_contact[1];
        f[3*i+2] += f_contact[2];
    }
}
```

**关键特点：**
- SDF在初始化后不随时间变化
- 可变形对象的位置变化通过查询静态SDF来检测碰撞
- 适用于刚体-可变形体碰撞检测

### 4.2 SDF不随可变形对象变形而更新

重要说明：**VegaFEM中的SDF不会随着可变形对象的变形而实时更新**。

原因：
1. **计算成本高**：重新计算SDF需要遍历所有网格顶点并计算到变形后网格的距离，时间复杂度为O(N*M)，其中N是SDF网格顶点数，M是可变形对象三角形面数。
2. **实时性要求**：物理模拟需要每秒60帧或更高的帧率，实时更新SDF会严重影响性能。
3. **设计选择**：VegaFEM采用静态SDF + 动态查询的设计，通过罚函数方法处理接触。

### 4.3 可变形对象-可变形对象碰撞

对于两个可变形对象之间的碰撞，VegaFEM采用不同的策略：

```cpp
// 方法1：使用网格相交检测
MeshIntersection meshIntersection;
bool intersecting = meshIntersection.checkIntersection(mesh1, mesh2);

// 方法2：使用连续碰撞检测（CCD）
for (int i = 0; i < numVertices1; i++) {
    Vec3d startPos = oldPos1[i];
    Vec3d endPos = newPos1[i];
    
    // 检测与mesh2的碰撞
    double contactTime = mesh2.pointCCD(startPos, endPos);
    
    if (contactTime >= 0 && contactTime <= 1.0) {
        // 发生碰撞，处理接触
    }
}
```

**关键特点：**
- 不使用SDF进行可变形对象-可变形对象碰撞检测
- 使用网格相交检测或连续碰撞检测（CCD）
- SDF主要用于刚体-可变形体碰撞

## 5. SDF变化的典型流程

### 5.1 初始化流程

```
加载网格 → 构建八叉树 → 计算无符号距离场 → 计算有符号距离场 → 保存SDF
```

**代码示例：**

```cpp
// 1. 加载网格
ObjMesh * mesh = new ObjMesh("model.obj");

// 2. 创建距离场
DistanceField * sdf = new DistanceField();

// 3. 计算有符号距离场
int code = sdf->computeSignedField(mesh, 256, 256, 256, 15, 10);

if (code != 0) {
    // 如果失败，尝试多边形网格方法
    DistanceFieldCreator creator;
    sdf = creator.ComputeDistanceField(256, 256, 256, 1, 
                                       DistanceFieldCreator::POLYGONSOUP,
                                       0.01, 1, false, 15, 10);
}

// 4. 保存SDF
sdf->save("distanceField.bin", false);
```

### 5.2 多边形网格方法中的SDF变化流程

```
计算无符号距离场 → 提取等值面 → 偏移距离场(-σ) → 洪水填充计算符号 → 偏移距离场(+σ)
```

**详细步骤：**

```cpp
// 步骤1：计算无符号距离场
field->computeUnsignedField(objMesh, resolutionX, resolutionY, resolutionZ, maxTriCount, maxDepth);

// 步骤2：提取等值面（距离 = sigma）
ObjMesh * isoMesh = ComputeIsosurface(field, sigma);

// 步骤3：偏移距离场（使等值面成为零等值面）
field->offsetDistanceField(-sigma);

// 步骤4：使用洪水填充计算有符号距离场
field->computeFloodFillSignedField(isoMesh, resolutionX, resolutionY, resolutionZ, maxTriCount, maxDepth);

// 步骤5：恢复偏移（如果需要）
if (subtractSigma)
    field->offsetDistanceField(sigma);

// 清理
delete isoMesh;
```

**变化过程说明：**

1. **初始状态**：无符号距离场，所有距离值 ≥ 0

2. **提取等值面**：找到距离 = sigma的所有点，构成等值面网格

3. **第一次偏移**：所有距离值减去sigma
   - 原等值面（距离=sigma）变为零等值面（距离=0）
   - 原网格表面（距离=0）变为负距离（距离=-sigma）

4. **洪水填充**：从等值面内部开始，将内部点的距离设为负值

5. **第二次偏移**：所有距离值加上sigma（如果需要）
   - 恢复原始的距离尺度

### 5.3 模拟循环中的SDF使用

```
加载预计算的SDF → 模拟循环开始 → 查询SDF检测碰撞 → 计算接触力 → 更新可变形对象位置 → 重复
```

**代码示例：**

```cpp
// 初始化：加载预计算的SDF
DistanceField * sdf = new DistanceField();
sdf->load("distanceField.bin");

// 模拟参数
double penaltyStiffness = 1e5;
double frictionCoeff = 0.5;

// 模拟循环
while (simulationRunning) {
    // 1. 计算弹性力
    femModel->ComputeForces(u, internalForces);
    
    // 2. 计算接触力（查询静态SDF）
    for (int i = 0; i < numVertices; i++) {
        Vec3d pos = currentPos[i];
        
        // 查询距离
        float d = sdf->distance(pos);
        
        if (d < 0) {
            // 穿透，计算接触力
            Vec3d n = sdf->gradient(pos);
            n.normalize();
            
            // 法向接触力
            Vec3d f_normal = penaltyStiffness * d * n;
            
            // 切向摩擦力
            Vec3d v = velocity[i];
            Vec3d v_t = v - dot(v, n) * n;
            
            Vec3d f_friction(0, 0, 0);
            if (v_t.length() > 1e-6) {
                Vec3d t = v_t / v_t.length();
                f_friction = -frictionCoeff * f_normal.length() * t;
            }
            
            // 总接触力
            Vec3d f_contact = f_normal + f_friction;
            
            // 添加到力向量
            internalForces[3*i] += f_contact[0];
            internalForces[3*i+1] += f_contact[1];
            internalForces[3*i+2] += f_contact[2];
        }
    }
    
    // 3. 时间积分
    integrator->Step(u, velocity, internalForces, dt);
    
    // 4. 更新可变形对象位置
    deformableObject->SetVertexDeformations(u);
    
    // 5. 渲染
    renderer->Render();
}
```

## 6. SDF变化的性能分析

### 6.1 计算复杂度

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 计算无符号距离场 | O(N*M) | O(N) | N=网格顶点数，M=三角形面数 |
| 计算有符号距离场 | O(N*M) | O(N) | 需要额外的符号判断 |
| 全局偏移 | O(N) | O(1) | 遍历所有网格顶点 |
| 局部修改 | O(1) | O(1) | 修改单个顶点 |
| 距离查询 | O(1) | O(1) | 三线性插值 |
| 梯度查询 | O(1) | O(1) | 基于三线性插值 |

### 6.2 内存占用

对于分辨率为256×256×256的SDF：

```
网格顶点数 = (256+1) × (256+1) × (256+1) = 16,777,216
内存占用 = 16,777,216 × 4字节 = 64 MB
```

### 6.3 性能优化策略

1. **使用八叉树加速**
   - 减少距离计算时需要检查的三角形数量
   - 时间复杂度从O(M)降低到O(log M)

2. **窄带距离场（Narrow Band）**
   - 只计算表面附近的距离值
   - 大幅减少内存占用和计算时间

3. **预计算和缓存**
   - 初始化时计算SDF并保存到文件
   - 模拟时直接加载，避免重复计算

4. **并行计算**
   - 使用多线程或GPU加速距离场计算
   - VegaFEM支持TBB并行计算

## 7. SDF变化的数学原理

### 7.1 距离场的数学定义

对于空间中的任意点p，其到表面S的符号距离定义为：

```
φ(p) = {
    d(p, S),  如果p在S外部
    -d(p, S), 如果p在S内部
}
```

其中d(p, S)是点p到表面S的最短欧氏距离：

```
d(p, S) = min_{q∈S} ||p - q||
```

### 7.2 三线性插值

对于位于体素内的点p，其距离值通过三线性插值计算：

```
φ(p) = (1-wx)(1-wy)(1-wz)·φ000
      + wx(1-wy)(1-wz)·φ100
      + wx·wy(1-wz)·φ110
      + (1-wx)·wy(1-wz)·φ010
      + (1-wx)(1-wy)wz·φ001
      + wx(1-wy)wz·φ101
      + wx·wy·wz·φ111
      + (1-wx)·wy·wz·φ011
```

其中：
- wx, wy, wz是点p在体素内的归一化坐标
- φijk是体素8个顶点的距离值

### 7.3 梯度计算

距离场的梯度指向距离增加最快的方向，在表面处即为表面法向量：

```
∇φ(p) = (∂φ/∂x, ∂φ/∂y, ∂φ/∂z)
```

对于三线性插值，梯度分量可以通过对插值公式求导得到：

```
∂φ/∂x = (1-wy)(1-wz)·(φ100 - φ000)
        + wy(1-wz)·(φ110 - φ010)
        + (1-wy)wz·(φ101 - φ001)
        + wy·wz·(φ111 - φ011)
```

∂φ/∂y和∂φ/∂z的计算类似。

### 7.4 偏移操作的数学含义

对距离场进行偏移σ相当于移动等值面：

```
φ'(p) = φ(p) + σ
```

这意味着：
- 原来的零等值面（φ(p)=0）变为φ'(p)=σ的等值面
- 原来的σ等值面（φ(p)=σ）变为φ'(p)=2σ的等值面
- 等值面沿着梯度方向移动距离σ

## 8. 实际应用示例

### 8.1 刚体-可变形体碰撞检测

```cpp
// 场景：一个可变形的球体与一个刚体立方体碰撞

// 初始化
ObjMesh * cubeMesh = new ObjMesh("cube.obj");
DistanceField * cubeSDF = new DistanceField();
cubeSDF->computeSignedField(cubeMesh, 128, 128, 128);

VolumetricMesh * sphereMesh = new TetMesh("sphere.tet");
StVKMaterial * material = new StVKMaterial(sphereMesh);
StVKFEM * femModel = new StVKFEM(sphereMesh, material);

// 模拟循环
while (true) {
    // 计算弹性力
    femModel->ComputeForces(u, internalForces);
    
    // 检测与立方体的碰撞
    for (int i = 0; i < sphereMesh->getNumVertices(); i++) {
        Vec3d pos = sphereMesh->getVertexPosition(i);
        
        float d = cubeSDF->distance(pos);
        
        if (d < 0) {
            // 穿透，计算接触力
            Vec3d n = cubeSDF->gradient(pos);
            n.normalize();
            
            Vec3d f_contact = 1e5 * d * n;
            
            internalForces[3*i] += f_contact[0];
            internalForces[3*i+1] += f_contact[1];
            internalForces[3*i+2] += f_contact[2];
        }
    }
    
    // 时间积分
    integrator->Step(u, velocity, internalForces, dt);
    
    // 更新位置
    for (int i = 0; i < sphereMesh->getNumVertices(); i++) {
        Vec3d restPos = sphereMesh->getRestVertexPosition(i);
        Vec3d disp(u[3*i], u[3*i+1], u[3*i+2]);
        sphereMesh->setVertexPosition(i, restPos + disp);
    }
}
```

### 8.2 使用偏移创建安全距离

```cpp
// 创建一个带有安全距离的SDF，避免穿透

DistanceField * sdf = new DistanceField();
sdf->computeSignedField(mesh, 256, 256, 256);

// 偏移距离场，创建安全距离
double safetyDistance = 0.01; // 1cm的安全距离
sdf->offsetDistanceField(safetyDistance);

// 现在查询距离时，会在距离表面1cm时就检测到"穿透"
for (int i = 0; i < numVertices; i++) {
    Vec3d pos = currentPos[i];
    float d = sdf->distance(pos);
    
    if (d < 0) {
        // 实际上还没有穿透，但已经进入了安全距离
        // 提前计算接触力，避免穿透
        Vec3d n = sdf->gradient(pos);
        n.normalize();
        Vec3d f_contact = penaltyStiffness * d * n;
        
        f[3*i] += f_contact[0];
        f[3*i+1] += f_contact[1];
        f[3*i+2] += f_contact[2];
    }
}
```

### 8.3 多个碰撞对象的SDF管理

```cpp
// 管理多个碰撞对象的SDF

struct CollisionObject {
    DistanceField * sdf;
    Vec3d position;
    Quaternion rotation;
    double penaltyStiffness;
};

vector<CollisionObject> collisionObjects;

// 初始化碰撞对象
CollisionObject obj1;
obj1.sdf = new DistanceField();
obj1.sdf->computeSignedField(new ObjMesh("cube1.obj"), 128, 128, 128);
obj1.position = Vec3d(0, 0, 0);
obj1.rotation = Quaternion(1, 0, 0, 0);
obj1.penaltyStiffness = 1e5;
collisionObjects.push_back(obj1);

CollisionObject obj2;
obj2.sdf = new DistanceField();
obj2.sdf->computeSignedField(new ObjMesh("cube2.obj"), 128, 128, 128);
obj2.position = Vec3d(1, 0, 0);
obj2.rotation = Quaternion(1, 0, 0, 0);
obj2.penaltyStiffness = 1e5;
collisionObjects.push_back(obj2);

// 模拟循环：检测与所有碰撞对象的碰撞
for (int i = 0; i < numVertices; i++) {
    Vec3d pos = currentPos[i];
    
    for (auto& obj : collisionObjects) {
        // 将位置转换到碰撞对象的局部坐标系
        Vec3d localPos = obj.rotation.inverse() * (pos - obj.position);
        
        float d = obj.sdf->distance(localPos);
        
        if (d < 0) {
            Vec3d n = obj.sdf->gradient(localPos);
            n = obj.rotation * n; // 转换回世界坐标系
            
            Vec3d f_contact = obj.penaltyStiffness * d * n;
            
            f[3*i] += f_contact[0];
            f[3*i+1] += f_contact[1];
            f[3*i+2] += f_contact[2];
        }
    }
}
```

## 9. 总结

### 9.1 SDF变化的关键点

1. **初始化阶段**：SDF在初始化时计算一次，之后保持静态
2. **变化方式**：主要通过全局偏移和局部修改来改变SDF
3. **查询机制**：通过三线性插值查询任意位置的距离和梯度
4. **交互方式**：可变形对象查询静态SDF来检测碰撞，SDF本身不随对象变形而更新

### 9.2 设计优势

1. **高效性**：静态SDF避免了实时更新的计算开销
2. **准确性**：基于精确的几何距离计算
3. **灵活性**：支持偏移操作调整碰撞容差
4. **可扩展性**：支持多个碰撞对象的管理

### 9.3 局限性

1. **不适用于可变形-可变形碰撞**：需要使用其他方法
2. **内存占用大**：高分辨率SDF需要大量内存
3. **初始化时间长**：首次计算SDF需要较长时间
4. **刚体假设**：假设碰撞对象是刚体，不随时间变形

### 9.4 适用场景

- 刚体-可变形体碰撞检测
- 复杂几何形状的碰撞检测
- 需要精确距离信息的应用
- 实时性要求不极端的场景

---

**文档版本**：1.0  
**最后更新**：2026-01-11  
**参考代码**：VegaFEM libraries/distanceField
