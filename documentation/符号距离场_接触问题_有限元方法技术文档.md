# VegaFEM 技术文档：符号距离场、接触问题与有限元方法

## 目录

1. [理论层面分析](#1-理论层面分析)
   - 1.1 [符号距离场](#11-符号距离场)
   - 1.2 [接触问题](#12-接触问题)
   - 1.3 [有限元方法](#13-有限元方法)
2. [公式层面剖析](#2-公式层面剖析)
   - 2.1 [符号距离场核心公式](#21-符号距离场核心公式)
   - 2.2 [接触问题控制方程](#22-接触问题控制方程)
   - 2.3 [有限元方法离散化公式](#23-有限元方法离散化公式)
3. [项目应用说明](#3-项目应用说明)
   - 3.1 [技术模块结合方式](#31-技术模块结合方式)
   - 3.2 [接口关系与数据传递](#32-接口关系与数据传递)
   - 3.3 [关键参数设置与优化](#33-关键参数设置与优化)
4. [数值算例](#4-数值算例)
5. [参考文献](#5-参考文献)

---

## 1. 理论层面分析

### 1.1 符号距离场

#### 1.1.1 数学定义

符号距离场（Signed Distance Field, SDF）是一个标量场 φ(x)，对于空间中的任意点 x，其值定义为：

```
φ(x) = s · d(x)
```

其中：
- d(x) 是点 x 到物体表面 Γ 的最小欧氏距离
- s 是符号，当 x 位于物体内部时为负值，位于外部时为正值
- Γ 是物体的边界曲面

数学表达式为：

```
φ(x) = {
  -min_{y∈Γ} ||x - y||,  如果 x 在物体内部
   min_{y∈Γ} ||x - y||,  如果 x 在物体外部
   0,                     如果 x ∈ Γ
}
```

#### 1.1.2 基本原理

符号距离场具有以下重要性质：

1. **距离性质**：|φ(x)| = min_{y∈Γ} ||x - y||
2. **梯度性质**：∇φ(x) 是从最近点指向 x 的单位向量
3. **符号性质**：sign(φ(x)) 表示点的内外状态
4. **连续性**：φ(x) 在整个空间中连续可微（除表面外）

#### 1.1.3 在VegaFEM中的应用场景

在VegaFEM项目中，符号距离场主要应用于：

1. **碰撞检测**：快速判断物体间的穿透状态
2. **接触力计算**：基于穿透深度计算接触力
3. **几何查询**：快速点到网格距离查询
4. **等值面提取**：使用Marching Cubes算法提取等值面
5. **网格处理**：处理非流形几何（polygon soup）

核心实现类包括：
- [DistanceField](file:///e:/workspace/VegaFEM/libraries/distanceField/distanceField.h)：基础距离场类
- [DistanceFieldBase](file:///e:/workspace/VegaFEM/libraries/distanceField/distanceFieldBase.h)：距离场基类
- [SignedDistanceFieldFromPolygonSoup](file:///e:/workspace/VegaFEM/libraries/distanceField/signedDistanceFieldFromPolygonSoup.h)：从多边形汤计算符号距离场
- [DistanceFieldCreator](file:///e:/workspace/VegaFEM/libraries/distanceField/distanceFieldCreator.h)：距离场创建器

### 1.2 接触问题

#### 1.2.1 力学基础

接触问题研究两个或多个物体在接触界面上的相互作用。基本力学原理包括：

1. **不可穿透条件**：接触物体不能相互穿透
2. **法向接触条件**：接触力只能为压力，不能为拉力
3. **切向摩擦条件**：遵循库仑摩擦定律

数学表述：

```
g_n(x) ≥ 0          (间隙约束)
f_n(x) ≥ 0          (法向力非负)
g_n(x) · f_n(x) = 0  (互补条件)
```

其中：
- g_n(x) 是法向间隙
- f_n(x) 是法向接触力

#### 1.2.2 分类

接触问题按不同标准分类：

1. **按接触类型**：
   - 点-点接触
   - 点-面接触
   - 面-面接触

2. **按摩擦类型**：
   - 无摩擦接触
   - 库仑摩擦接触
   - 粘性摩擦接触

3. **按接触状态**：
   - 粘着接触（Stick）
   - 滑动接触（Slip）
   - 分离状态（Separation）

#### 1.2.3 数值处理方法

VegaFEM中采用的接触问题数值处理方法：

1. **罚函数法（Penalty Method）**：
   - 将接触约束转化为罚力
   - 穿透深度 d 产生接触力 f = k · d
   - 优点：实现简单，计算高效
   - 缺点：需要选择合适的罚参数

2. **拉格朗日乘子法（Lagrange Multiplier）**：
   - 引入拉格朗日乘子精确满足约束
   - 优点：精确满足不可穿透条件
   - 缺点：增加系统规模，计算复杂

3. **增广拉格朗日法（Augmented Lagrangian）**：
   - 结合罚函数法和拉格朗日乘子法
   - 平衡精度和效率

#### 1.2.4 在VegaFEM中的实现

VegaFEM通过以下方式处理接触问题：

1. **基于距离场的碰撞检测**：
   - 使用符号距离场快速检测穿透
   - 计算穿透深度和法向量

2. **连续碰撞检测（CCD）**：
   - [pointCCD](file:///e:/workspace/VegaFEM/libraries/distanceField/distanceField.h#L212) 方法计算最早接触时间
   - 防止高速运动时的穿透

3. **网格相交检测**：
   - [meshIntersection](file:///e:/workspace/VegaFEM/libraries/mesh/meshIntersection.h) 处理网格相交
   - [iglRemeshSelfIntersection](file:///e:/workspace/VegaFEM/libraries/libiglInterface/iglRemeshSelfIntersection.h) 处理自相交

### 1.3 有限元方法

#### 1.3.1 基本理论框架

有限元方法（Finite Element Method, FEM）是一种数值求解偏微分方程的方法。在固体力学中，基本步骤包括：

1. **弱形式推导**：
   从平衡方程出发，利用虚功原理得到弱形式：

   ```
   ∫_Ω σ:δε dΩ = ∫_Ω f·δu dΩ + ∫_Γ t·δu dΓ
   ```

   其中：
   - σ 是柯西应力张量
   - ε 是应变张量
   - f 是体力
   - t 是面力
   - δu 是虚位移

2. **空间离散化**：
   将求解域 Ω 离散化为有限个单元 Ω_e：

   ```
   Ω = ∪_e Ω_e
   ```

3. **形函数插值**：
   单元内位移场用形函数插值：

   ```
   u(x) = Σ_i N_i(x) u_i
   ```

   其中 N_i(x) 是形函数，u_i 是节点位移。

4. **单元刚度矩阵**：
   单元刚度矩阵 K_e 通过积分得到：

   ```
   K_e = ∫_Ω_e B^T D B dΩ
   ```

   其中：
   - B 是应变-位移矩阵
   - D 是本构矩阵

5. **整体组装**：
   将单元刚度矩阵组装成整体刚度矩阵：

   ```
   K = A_e K_e
   ```

   其中 A_e 是组装算子。

#### 1.3.2 在VegaFEM中的具体实现

VegaFEM实现了多种有限元方法：

1. **线性有限元（Linear FEM）**：
   - 基于小变形假设
   - 刚度矩阵恒定
   - 适用于小变形问题

2. **共旋转线性有限元（Corotational Linear FEM）**：
   - [CorotationalLinearFEM](file:///e:/workspace/VegaFEM/libraries/corotationalLinearFEM/corotationalLinearFEM.h) 类实现
   - 处理大变形问题
   - 支持三种模式：
     * warp=0：无旋转（线性FEM）
     * warp=1：近似刚度矩阵旋转 [Mueller 2004]
     * warp=2：精确切线刚度矩阵 [Barbic 2012]

3. **各向同性超弹性有限元（Isotropic Hyperelastic FEM）**：
   - [IsotropicHyperelasticFEM](file:///e:/workspace/VegaFEM/libraries/isotropicHyperelasticFEM/isotropicHyperelasticFEM.h) 类实现
   - 支持多种超弹性材料模型
   - 处理大变形和单元翻转
   - 基于块对角 dP/dF 张量计算切线刚度矩阵 [Teran 2005]

4. **St. Venant-Kirchhoff 有限元（StVK FEM）**：
   - 基于StVK材料模型
   - 适用于中等变形
   - 预计算积分提高效率

#### 1.3.3 单元类型

VegaFEM支持以下单元类型：

1. **四面体单元（Tetrahedral Elements）**：
   - 4个节点
   - 线性形函数
   - 适用于复杂几何

2. **立方体单元（Cubic Elements）**：
   - 8个节点
   - 三线性形函数
   - 适用于规则网格

#### 1.3.4 材料模型

VegaFEM支持多种材料模型：

1. **各向同性材料**：
   - Neo-Hookean
   - Mooney-Rivlin
   - St. Venant-Kirchhoff (StVK)

2. **正交各向异性材料**：
   - [Stable Orthotropic Materials](file:///e:/workspace/VegaFEM/libraries/corotationalLinearFEM/corotationalLinearFEM.h#L51) [Li & Barbic 2014]

---

## 2. 公式层面剖析

### 2.1 符号距离场核心公式

#### 2.1.1 基本计算公式

对于给定的三角形网格，符号距离场的计算涉及以下步骤：

1. **有符号距离计算**：

   对于点 x，到三角形 T 的有符号距离为：

   ```
   d_signed(x, T) = s · ||x - p_closest||
   ```

   其中：
   - p_closest 是三角形上距离 x 最近的点
   - s 是符号，由点与三角形法向量的点积确定

2. **符号确定**：

   符号 s 通过伪法向量测试确定：

   ```
   s = sign(n_pseudo · (x - p_closest))
   ```

   其中 n_pseudo 是伪法向量，考虑了顶点和边的贡献。

3. **整体距离场**：

   点 x 的距离场值为：

   ```
   φ(x) = min_{T∈Mesh} d_signed(x, T)
   ```

#### 2.1.2 三线性插值

在体素网格中，任意位置的距离值通过三线性插值计算：

```
φ(x,y,z) = Σ_{i=0}^1 Σ_{j=0}^1 Σ_{k=0}^1 
           N_i(u) N_j(v) N_k(w) φ_{i,j,k}
```

其中：
- (u,v,w) 是局部坐标，范围 [0,1]
- N_0(t) = 1 - t, N_1(t) = t
- φ_{i,j,k} 是体素顶点的距离值

#### 2.1.3 梯度计算

距离场的梯度通过三线性插值的导数计算：

```
∇φ(x,y,z) = [∂φ/∂x, ∂φ/∂y, ∂φ/∂z]^T
```

其中：

```
∂φ/∂x = (1/Δx) Σ_{j=0}^1 Σ_{k=0}^1 
        N_j(v) N_k(w) (φ_{1,j,k} - φ_{0,j,k})
```

类似地计算 ∂φ/∂y 和 ∂φ/∂z。

#### 2.1.4 多边形汤符号距离场

对于非流形几何（多边形汤），采用以下算法 [Xu & Barbic 2014]：

1. **计算无符号距离场**：
   ```
   φ_unsigned(x) = min_{T∈Mesh} ||x - p_closest||
   ```

2. **提取等值面**：
   使用 Marching Cubes 算法从 φ_unsigned 提取 σ 等值面：
   ```
   Γ_σ = {x | φ_unsigned(x) = σ}
   ```

3. **计算符号距离场**：
   对 Γ_σ 计算符号距离场 φ_signed

4. **偏移校正**：
   ```
   φ_final(x) = φ_signed(x) - σ
   ```

#### 2.1.5 八叉树加速

为了加速距离计算，VegaFEM使用八叉树空间划分：

1. **八叉树构建**：
   - 递归将空间划分为八个子区域
   - 参数控制：
     * maxDepth：最大深度
     * maxTriCount：每个单元最大三角形数

2. **距离查询**：
   - 从根节点开始遍历
   - 只检查与查询点相关的单元
   - 时间复杂度：O(log N)

### 2.2 接触问题控制方程

#### 2.2.1 接触约束

接触问题的基本约束条件：

1. **不可穿透条件**：
   ```
   g_n(x,t) ≥ 0,  ∀ x ∈ Γ_c, t ∈ [0,T]
   ```
   其中 g_n 是法向间隙函数。

2. **法向力条件**：
   ```
   f_n(x,t) ≥ 0,  ∀ x ∈ Γ_c, t ∈ [0,T]
   ```
   法向接触力只能为压力。

3. **互补条件**：
   ```
   g_n(x,t) · f_n(x,t) = 0,  ∀ x ∈ Γ_c, t ∈ [0,T]
   ```
   接触力只在接触时存在。

#### 2.2.2 罚函数法

罚函数法将接触约束转化为罚力：

```
f_n(x) = {
  k_p · g_n(x),  如果 g_n(x) < 0（穿透）
  0,             如果 g_n(x) ≥ 0（未接触）
}
```

其中 k_p 是罚参数（刚度）。

对于小穿透深度，接触力可近似为：

```
f_n ≈ k_p · d
```

其中 d 是穿透深度。

#### 2.2.3 库仑摩擦

切向摩擦遵循库仑定律：

```
f_t ≤ μ · f_n
```

其中：
- f_t 是切向摩擦力
- μ 是摩擦系数

摩擦状态判定：

1. **粘着状态（Stick）**：
   ```
   ||f_t|| < μ · f_n
   v_t = 0
   ```

2. **滑动状态（Slip）**：
   ```
   ||f_t|| = μ · f_n
   f_t = -μ · f_n · (v_t / ||v_t||)
   ```

#### 2.2.4 基于距离场的接触检测

使用符号距离场进行接触检测：

1. **穿透检测**：
   ```
   if φ(x) < 0:
       穿透深度 d = |φ(x)|
       法向量 n = ∇φ(x) / ||∇φ(x)||
   ```

2. **接触力计算**：
   ```
   f_contact = k_p · d · n
   ```

3. **连续碰撞检测（CCD）**：

   对于以恒定速度运动的点，最早接触时间 t_c 为：

   ```
   t_c = argmin_{t∈[0,1]} φ(x_0 + t·v)
   ```

   其中 x_0 是起始位置，v 是速度向量。

#### 2.2.5 离散化公式

在有限元离散化后，接触力向量为：

```
F_contact = Σ_{i∈Γ_c} N_i^T(x_i) f_contact(x_i)
```

其中：
- N_i 是节点 i 的形函数
- x_i 是接触点

### 2.3 有限元方法离散化公式

#### 2.3.1 运动方程

连续介质力学中的运动方程：

```
ρ ü = ∇·σ + f
```

其中：
- ρ 是密度
- ü 是加速度
- σ 是柯西应力张量
- f 是体力

#### 2.3.2 弱形式

利用虚功原理，得到弱形式：

```
∫_Ω ρ ü·δu dΩ + ∫_Ω σ:δε dΩ = ∫_Ω f·δu dΩ + ∫_Γ t·δu dΓ
```

其中：
- δu 是虚位移
- δε 是虚应变

#### 2.3.3 空间离散化

位移场用形函数插值：

```
u(x,t) = Σ_{i=1}^{n} N_i(x) u_i(t)
```

其中：
- N_i(x) 是形函数
- u_i(t) 是节点位移
- n 是节点数

应变-位移关系：

```
ε = B u
```

其中 B 是应变-位移矩阵：

```
B = [∂N_1/∂x, 0, 0, ∂N_2/∂x, 0, 0, ...]
    [0, ∂N_1/∂y, 0, 0, ∂N_2/∂y, 0, ...]
    [0, 0, ∂N_1/∂z, 0, 0, ∂N_2/∂z, ...]
    [∂N_1/∂y, ∂N_1/∂x, 0, ∂N_2/∂y, ∂N_2/∂x, 0, ...]
    [0, ∂N_1/∂z, ∂N_1/∂y, 0, ∂N_2/∂z, ∂N_2/∂y, ...]
    [∂N_1/∂z, 0, ∂N_1/∂x, ∂N_2/∂z, 0, ∂N_2/∂x, ...]
```

#### 2.3.4 单元刚度矩阵

对于线性弹性材料，本构关系为：

```
σ = D ε
```

其中 D 是本构矩阵（弹性张量）。

单元刚度矩阵：

```
K_e = ∫_Ω_e B^T D B dΩ
```

对于四面体单元，使用数值积分：

```
K_e ≈ Σ_{q=1}^{n_q} w_q B^T(x_q) D B(x_q) |J_e(x_q)|
```

其中：
- w_q 是积分权重
- x_q 是积分点
- J_e 是雅可比矩阵

#### 2.3.5 整体刚度矩阵组装

将单元刚度矩阵组装成整体刚度矩阵：

```
K = Σ_e A_e^T K_e A_e
```

其中 A_e 是单元-节点关联矩阵。

#### 2.3.6 质量矩阵

一致质量矩阵：

```
M_e = ∫_Ω_e ρ N^T N dΩ
```

集中质量矩阵：

```
M_e = diag(∫_Ω_e ρ N dΩ)
```

#### 2.3.7 非线性有限元

对于大变形问题，使用非线性有限元方法。

1. **变形梯度**：
   ```
   F = ∂x/∂X = I + ∂u/∂X
   ```

2. **右Cauchy-Green张量**：
   ```
   C = F^T F
   ```

3. **Green-Lagrange应变**：
   ```
   E = 1/2 (C - I)
   ```

4. **第二Piola-Kirchhoff应力**：
   ```
   S = ∂W/∂E
   ```

   其中 W 是应变能密度。

5. **切线刚度矩阵**：
   ```
   K_T = K_material + K_geometric
   ```

   其中：
   - K_material 是材料刚度矩阵
   - K_geometric 是几何刚度矩阵

#### 2.3.8 共旋转有限元

共旋转有限元通过局部坐标系处理大变形：

1. **极分解**：
   ```
   F = R U
   ```

   其中 R 是旋转矩阵，U 是右拉伸张量。

2. **局部应变**：
   ```
   ε_local = U - I
   ```

3. **旋转后的刚度矩阵**：
   ```
   K_warped = R K_0 R^T
   ```

   其中 K_0 是未变形时的刚度矩阵。

在VegaFEM中，[WarpMatrix](file:///e:/workspace/VegaFEM/libraries/corotationalLinearFEM/corotationalLinearFEM.h#L120) 函数实现刚度矩阵旋转：

```
void WarpMatrix(double * K, double * R, double * RK, double * RKRT)
```

#### 2.3.9 超弹性有限元

对于超弹性材料，应变能密度 W 是变形梯度的函数：

```
W = W(F)
```

第一Piola-Kirchhoff应力：

```
P = ∂W/∂F
```

切线刚度矩阵基于 dP/dF 张量：

```
K = ∫_Ω B^T (dP/dF) B dΩ
```

在VegaFEM中，[IsotropicHyperelasticFEM](file:///e:/workspace/VegaFEM/libraries/isotropicHyperelasticFEM/isotropicHyperelasticFEM.h) 实现了基于块对角 dP/dF 张量的计算方法 [Teran 2005]。

#### 2.3.10 时间积分

运动方程的离散化：

```
M ü + C u̇ + F_int(u) = F_ext
```

其中：
- M 是质量矩阵
- C 是阻尼矩阵
- F_int 是内力
- F_ext 是外力

隐式Newmark方法：

```
u_{n+1} = u_n + Δt u̇_n + Δt²[(1/2 - β) ü_n + β ü_{n+1}]
u̇_{n+1} = u̇_n + Δt[(1 - γ) ü_n + γ ü_{n+1}]
```

其中 β 和 γ 是Newmark参数。

---

## 3. 项目应用说明

### 3.1 技术模块结合方式

#### 3.1.1 整体架构

VegaFEM中三种技术的结合方式如下图所示：

```
┌─────────────────────────────────────────────────────────┐
│                    VegaFEM 仿真系统                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────────┐    ┌──────────────┐                  │
│  │  符号距离场   │◄───┤   接触处理    │                  │
│  │  (SDF)      │    │   (Contact)  │                  │
│  └──────┬───────┘    └──────┬───────┘                  │
│         │                   │                            │
│         ▼                   ▼                            │
│  ┌──────────────────────────────────┐                  │
│  │        有限元求解器 (FEM)          │                  │
│  │  ┌────────────────────────────┐  │                  │
│  │  │  CorotationalLinearFEM      │  │                  │
│  │  │  IsotropicHyperelasticFEM   │  │                  │
│  │  │  StVKFEM                    │  │                  │
│  │  └────────────────────────────┘  │                  │
│  └──────────────────────────────────┘                  │
│                  │                                       │
│                  ▼                                       │
│  ┌──────────────────────────────────┐                  │
│  │        时间积分器 (Integrator)    │                  │
│  │  ┌────────────────────────────┐  │                  │
│  │  │  ImplicitNewmarkSparse     │  │                  │
│  │  │  ImplicitBackwardEuler     │  │                  │
│  │  │  CentralDifferences        │  │                  │
│  │  └────────────────────────────┘  │                  │
│  └──────────────────────────────────┘                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 3.1.2 典型工作流程

1. **预处理阶段**：
   ```
   输入网格 → 构建八叉树 → 计算距离场 → 预计算FEM积分
   ```

2. **仿真循环**：
   ```
   for each time step:
       1. 检测碰撞（使用SDF）
       2. 计算接触力
       3. 计算内力（FEM）
       4. 组装系统方程
       5. 时间积分求解
       6. 更新位置和速度
   ```

#### 3.1.3 具体应用场景

1. **软体碰撞仿真**：
   - 使用符号距离场检测软体与刚体的碰撞
   - 使用罚函数法计算接触力
   - 使用超弹性FEM模拟软体变形

2. **自相交处理**：
   - 使用距离场检测网格自相交
   - 使用 [iglRemeshSelfIntersection](file:///e:/workspace/VegaFEM/libraries/libiglInterface/iglRemeshSelfIntersection.h) 修复网格

3. **网格切割**：
   - 使用距离场确定切割路径
   - 重新网格化切割区域

### 3.2 接口关系与数据传递

#### 3.2.1 核心类接口

1. **距离场接口**：

   [DistanceField](file:///e:/workspace/VegaFEM/libraries/distanceField/distanceField.h) 类提供以下关键接口：

   ```cpp
   // 计算无符号距离场
   int computeUnsignedField(ObjMesh * objMesh, 
                            int resolutionX, int resolutionY, int resolutionZ,
                            int maxTriCount=15, int maxDepth=10);

   // 计算有符号距离场
   int computeSignedField(ObjMesh * objMesh, 
                         int resolutionX, int resolutionY, int resolutionZ,
                         int maxTriCount=15, int maxDepth=10);

   // 查询距离值
   float distance(int i, int j, int k) const;
   float distance(Vec3d pos, int constrainToBox=0) const;

   // 计算梯度
   Vec3d gradient(const Vec3d& pos);

   // 连续碰撞检测
   double pointCCD(Vec3d startPos, Vec3d endPos);
   ```

2. **有限元接口**：

   [CorotationalLinearFEM](file:///e:/workspace/VegaFEM/libraries/corotationalLinearFEM/corotationalLinearFEM.h) 类提供：

   ```cpp
   // 计算能量、力和刚度矩阵
   void ComputeEnergyAndForceAndStiffnessMatrix(
       const double * vertexDisplacements,
       double * energy,
       double * internalForces,
       SparseMatrix * stiffnessMatrix,
       int warp=1);

   // 获取刚度矩阵拓扑
   void GetStiffnessMatrixTopology(SparseMatrix ** stiffnessMatrixTopology);
   ```

   [IsotropicHyperelasticFEM](file:///e:/workspace/VegaFEM/libraries/isotropicHyperelasticFEM/isotropicHyperelasticFEM.h) 类提供：

   ```cpp
   // 计算应变能
   double ComputeEnergy(const double * u);

   // 计算内力
   void ComputeForces(const double * u, double * internalForces);

   // 获取切线刚度矩阵
   void GetTangentStiffnessMatrix(const double * u, 
                                   SparseMatrix * tangentStiffnessMatrix);

   // 同时计算力和刚度矩阵
   void GetForceAndTangentStiffnessMatrix(const double * u,
                                           double * internalForces,
                                           SparseMatrix * tangentStiffnessMatrix);
   ```

3. **力模型接口**：

   [ForceModel](file:///e:/workspace/VegaFEM/libraries/forceModel/forceModel.h) 基类定义了统一接口：

   ```cpp
   // 计算内力
   virtual int ComputeForce(double * u, double * force) = 0;

   // 计算刚度矩阵
   virtual int ComputeStiffnessMatrix(double * u, 
                                       SparseMatrix * stiffnessMatrix) = 0;

   // 计算力和刚度矩阵
   virtual int ComputeForceAndStiffnessMatrix(
       double * u, double * force, 
       SparseMatrix * stiffnessMatrix) = 0;
   ```

#### 3.2.2 数据传递流程

1. **从距离场到接触力**：

   ```
   DistanceField::distance(pos) 
       → 穿透深度 d
       → 接触力 f = k_p * d * n
       → 添加到外力向量 F_ext
   ```

2. **从位移到内力**：

   ```
   位移向量 u
       → FEM::ComputeForces(u)
       → 内力向量 F_int
       → 添加到系统方程
   ```

3. **从位移到刚度矩阵**：

   ```
   位移向量 u
       → FEM::GetTangentStiffnessMatrix(u)
       → 刚度矩阵 K
       → 组装到系统矩阵
   ```

4. **完整的数据流**：

   ```
   输入：位移 u
     ↓
   ┌─────────────────────────────────┐
   │ 1. 距离查询                     │
   │    φ = DistanceField::distance(x)│
   └─────────────────────────────────┘
     ↓
   ┌─────────────────────────────────┐
   │ 2. 接触力计算                   │
   │    F_contact = Penalty(φ)       │
   └─────────────────────────────────┘
     ↓
   ┌─────────────────────────────────┐
   │ 3. 内力计算                     │
   │    F_int = FEM::ComputeForces(u)│
   └─────────────────────────────────┘
     ↓
   ┌─────────────────────────────────┐
   │ 4. 刚度矩阵计算                 │
   │    K = FEM::GetStiffnessMatrix(u)│
   └─────────────────────────────────┘
     ↓
   ┌─────────────────────────────────┐
   │ 5. 系统方程组装                 │
   │    (M + h²K)Δu = h²(F_ext - F_int)│
   └─────────────────────────────────┘
     ↓
   输出：位移增量 Δu
   ```

#### 3.2.3 关键数据结构

1. **距离场数据**：

   ```cpp
   float * distanceData;  // 距离值数组
   int resolutionX, resolutionY, resolutionZ;  // 分辨率
   Vec3d bmin_, bmax_;  // 边界框
   double gridX, gridY, gridZ;  // 网格间距
   ```

2. **有限元数据**：

   ```cpp
   VolumetricMesh * volumetricMesh;  // 体积网格
   double ** KElementUndeformed;  // 单元刚度矩阵
   double * undeformedPositions;  // 未变形位置
   int ** rowIndices, ** columnIndices;  // 索引加速
   ```

3. **力模型数据**：

   ```cpp
   double * u;  // 位移向量
   double * f;  // 力向量
   SparseMatrix * K;  // 刚度矩阵
   ```

### 3.3 关键参数设置与优化

#### 3.3.1 距离场参数

1. **分辨率设置**：

   ```cpp
   int resolutionX = 256;
   int resolutionY = 256;
   int resolutionZ = 256;
   ```

   - 高分辨率：精度高，内存消耗大
   - 低分辨率：速度快，精度低
   - 建议：根据物体尺寸和精度要求选择

2. **八叉树参数**：

   ```cpp
   int maxTriCount = 15;  // 每个单元最大三角形数
   int maxDepth = 10;     // 最大深度
   ```

   - maxTriCount：控制八叉树细分
   - maxDepth：限制递归深度
   - 优化：根据网格复杂度调整

3. **边界框参数**：

   ```cpp
   double expansionRatio = 1.5;  // 扩展比例
   bool useCubicBox = true;       // 是否使用立方体边界框
   ```

   - expansionRatio：控制边界框大小
   - useCubicBox：立方体边界框便于计算

#### 3.3.2 接触参数

1. **罚参数**：

   ```cpp
   double penaltyStiffness = 1e5;  // 罚刚度
   ```

   - 过大：数值不稳定
   - 过小：穿透严重
   - 建议：通过实验调整

2. **摩擦系数**：

   ```cpp
   double frictionCoefficient = 0.5;  // 摩擦系数
   ```

   - 0：无摩擦
   - 1：高摩擦
   - 典型值：0.3-0.7

3. **连续碰撞检测参数**：

   ```cpp
   double ccdTolerance = 1e-6;  // CCD容差
   ```

#### 3.3.3 有限元参数

1. **材料参数**：

   对于各向同性材料：

   ```cpp
   double YoungsModulus = 1e6;  // 杨氏模量 (Pa)
   double PoissonRatio = 0.45;  // 泊松比
   ```

   - YoungsModulus：材料刚度
   - PoissonRatio：横向变形比（0-0.5）

2. **共旋转参数**：

   ```cpp
   int warp = 1;  // 旋转模式
   ```

   - warp=0：线性FEM（无旋转）
   - warp=1：近似刚度矩阵旋转
   - warp=2：精确切线刚度矩阵

3. **超弹性参数**：

   ```cpp
   double inversionThreshold = 0.1;  // 翻转阈值
   bool enforceSPD = true;           // 强制SPD
   ```

   - inversionThreshold：防止单元翻转
   - enforceSPD：保证刚度矩阵正定

#### 3.3.4 时间积分参数

1. **时间步长**：

   ```cpp
   double timestep = 0.001;  // 时间步长 (s)
   ```

   - 隐式方法：可使用较大步长
   - 显式方法：需要小步长（CFL条件）
   - 建议：通过稳定性分析确定

2. **Newmark参数**：

   ```cpp
   double beta = 0.25;   // Newmark beta参数
   double gamma = 0.5;   // Newmark gamma参数
   ```

   - beta=0.25, gamma=0.5：平均加速度法（无条件稳定）
   - beta=0, gamma=0.5：中心差分法

3. **阻尼参数**：

   ```cpp
   double dampingMass = 0.01;   // 质量阻尼系数
   double dampingStiffness = 0.001;  // 刚度阻尼系数
   ```

   - Rayleigh阻尼：C = αM + βK
   - α：质量阻尼（低频）
   - β：刚度阻尼（高频）

#### 3.3.5 性能优化

1. **预计算优化**：

   ```cpp
   // 预计算单元刚度矩阵
   double ** KElementUndeformed;
   ```

   - 在初始化时计算并存储
   - 运行时直接查询，避免重复计算

2. **稀疏矩阵优化**：

   ```cpp
   // 使用稀疏矩阵存储
   SparseMatrix * stiffnessMatrix;
   ```

   - 只存储非零元素
   - 减少内存消耗和计算时间

3. **并行计算**：

   ```cpp
   // 并行计算单元贡献
   #pragma omp parallel for
   for (int el = 0; el < numElements; el++) {
       // 计算单元能量、力、刚度矩阵
   }
   ```

   - 使用OpenMP并行化
   - 加速单元级计算

4. **自适应时间步长**：

   ```cpp
   // 根据变形程度调整时间步长
   if (maxDeformation > threshold) {
       timestep *= 0.5;
   }
   ```

   - 大变形时减小步长
   - 小变形时增大步长

---

## 4. 数值算例

### 4.1 算例1：球体与平面碰撞

#### 4.1.1 问题描述

一个弹性球体从高度 H 自由落下，与刚性平面碰撞。

#### 4.1.2 参数设置

```cpp
// 球体参数
double radius = 0.1;  // 半径 (m)
double mass = 1.0;    // 质量 (kg)
double E = 1e6;       // 杨氏模量 (Pa)
double nu = 0.45;     // 泊松比

// 初始条件
double H = 1.0;       // 初始高度 (m)
Vec3d initialPos(0, 0, H);
Vec3d initialVel(0, 0, 0);

// 接触参数
double penaltyStiffness = 1e5;  // 罚刚度
double frictionCoeff = 0.3;     // 摩擦系数

// 时间积分参数
double timestep = 0.001;       // 时间步长 (s)
double totalTime = 2.0;          // 总时间 (s)
```

#### 4.1.3 实现步骤

1. **创建距离场**：

```cpp
// 创建平面距离场
DistanceFieldCreator creator;
creator.setAutomaticBoundingBox(true, 1.5);
DistanceField * planeField = creator.ComputeDistanceField(
    128, 128, 128,  // 分辨率
    0,              // 无符号
    DistanceFieldCreator::BASIC,
    0.0,            // sigma
    1,              // subtractSigma
    false,          // computeVoronoiDiagram
    15,             // maxTriCount
    10              // maxDepth
);
```

2. **创建FEM模型**：

```cpp
// 创建球体网格
TetMesh * sphereMesh = new TetMesh("sphere.tet");

// 创建共旋转线性FEM模型
CorotationalLinearFEM * fem = new CorotationalLinearFEM(sphereMesh);

// 设置材料参数
fem->SetMaterial(E, nu);
```

3. **仿真循环**：

```cpp
double * u = new double[3 * numVertices];
double * v = new double[3 * numVertices];
double * f = new double[3 * numVertices];

for (double t = 0; t < totalTime; t += timestep) {
    // 1. 计算内力
    fem->ComputeForces(u, f);
    
    // 2. 检测碰撞并计算接触力
    for (int i = 0; i < numVertices; i++) {
        Vec3d pos = initialPos + Vec3d(u[3*i], u[3*i+1], u[3*i+2]);
        float d = planeField->distance(pos);
        
        if (d < 0) {
            // 穿透，计算接触力
            Vec3d n = planeField->gradient(pos);
            n.normalize();
            Vec3d f_contact = penaltyStiffness * d * n;
            
            f[3*i] += f_contact[0];
            f[3*i+1] += f_contact[1];
            f[3*i+2] += f_contact[2];
        }
    }
    
    // 3. 时间积分
    integrator->DoTimestep(f, u, v, timestep);
}
```

#### 4.1.4 结果分析

- 球体接触平面时产生弹性变形
- 最大变形深度与罚刚度相关
- 碰撞后球体反弹，能量守恒（无阻尼时）

### 4.2 算例2：软体自相交检测与修复

#### 4.2.1 问题描述

一个软体在剧烈变形下可能产生自相交，需要检测并修复。

#### 4.2.2 参数设置

```cpp
// 软体参数
double E = 1e5;       // 杨氏模量 (Pa)
double nu = 0.45;     // 泊松比
double density = 1000; // 密度 (kg/m³)

// 距离场参数
int resolution = 256;  // 分辨率
double sigma = 0.01;  // 等值面偏移 (m)
```

#### 4.2.3 实现步骤

1. **计算符号距离场**：

```cpp
// 使用多边形汤方法计算符号距离场
SignedDistanceFieldFromPolygonSoup sdfCreator(mesh, 1.5, true);

DistanceField * sdf = sdfCreator.ComputeDistanceField(
    resolution, resolution, resolution,
    sigma,      // sigma
    1,          // subtractSigma
    false,      // computeVoronoiDiagram
    15,         // maxTriCount
    10,         // maxDepth
    0,          // closestPointFlag
    NULL        // precomputedUnsignedFieldFilename
);
```

2. **检测自相交**：

```cpp
bool hasSelfIntersection = false;
for (int i = 0; i < numVertices; i++) {
    Vec3d pos = currentPos[i];
    float d = sdf->distance(pos);
    
    // 如果距离为负且绝对值较大，可能存在自相交
    if (d < -sigma * 2) {
        hasSelfIntersection = true;
        break;
    }
}
```

3. **修复自相交**：

```cpp
if (hasSelfIntersection) {
    // 使用libigl修复自相交
    ObjMesh * fixedMesh = iglRemeshSelfIntersection(mesh);
    
    // 重新计算距离场
    delete sdf;
    sdf = sdfCreator.ComputeDistanceField(
        resolution, resolution, resolution,
        sigma, 1, false, 15, 10, 0, NULL
    );
}
```

#### 4.2.4 结果分析

- 符号距离场能够有效检测自相交
- 多边形汤方法适用于非流形几何
- 修复后网格拓扑保持一致

### 4.3 算例3：超弹性材料大变形

#### 4.3.1 问题描述

一个超弹性立方体在拉伸载荷下产生大变形。

#### 4.3.2 参数设置

```cpp
// Neo-Hookean材料参数
double shearModulus = 1e5;   // 剪切模量 (Pa)
double bulkModulus = 1e6;   // 体积模量 (Pa)

// 网格参数
int numElements = 1000;     // 单元数

// 载荷参数
double stretch = 2.0;        // 拉伸比
```

#### 4.3.3 实现步骤

1. **创建超弹性FEM模型**：

```cpp
// 创建四面体网格
TetMesh * mesh = new TetMesh("cube.tet");

// 创建Neo-Hookean材料
NeoHookeanMaterial * material = new NeoHookeanMaterial(
    mesh, shearModulus, bulkModulus
);

// 创建超弹性FEM模型
IsotropicHyperelasticFEM * fem = new IsotropicHyperelasticFEM(
    mesh, material, 0.1  // inversionThreshold
);
```

2. **施加拉伸载荷**：

```cpp
double * u = new double[3 * numVertices];
double * f = new double[3 * numVertices];

// 固定底面
for (int i = 0; i < numVertices; i++) {
    if (mesh->getVertexPosition(i)[1] < 0.01) {
        u[3*i] = 0;
        u[3*i+1] = 0;
        u[3*i+2] = 0;
    }
}

// 逐步拉伸顶面
for (double s = 1.0; s <= stretch; s += 0.1) {
    // 设置顶面位移
    for (int i = 0; i < numVertices; i++) {
        if (mesh->getVertexPosition(i)[1] > 0.99) {
            u[3*i+1] = (s - 1.0) * height;
        }
    }
    
    // 计算内力
    fem->ComputeForces(u, f);
    
    // 求解平衡方程
    solver->Solve(f, u);
}
```

3. **计算应变能**：

```cpp
double energy = fem->ComputeEnergy(u);
printf("Strain energy: %f J\n", energy);
```

#### 4.3.4 结果分析

- 大变形下材料表现出非线性
- 应变能随拉伸比非线性增长
- 翻转阈值机制防止单元翻转

---

## 5. 参考文献

### 5.1 符号距离场

1. Hongyi Xu, Jernej Barbic: "Signed Distance Fields for Polygon Soup Meshes", Graphics Interface 2014, Montreal, Canada

2. Jernej Barbic, Hongyi Xu, Yijing Li: "VegaFEM Distance Field Library", USC, 2018

3. S. F. Frisken, R. N. Perry, A. P. Rockwood, T. R. Jones: "Adaptively Sampled Distance Fields: A General Representation of Shape for Computer Graphics", SIGGRAPH 2000

### 5.2 接触问题

1. P. Wriggers: "Computational Contact Mechanics", Springer, 2006

2. T. A. Laursen: "Computational Contact and Impact Mechanics", Springer, 2002

3. M. Anitescu, F. A. Potra: "Formulating Dynamic Multi-rigid-body Contact Problems with Friction as Solvable Linear Complementarity Problems", Nonlinear Dynamics, 1997

### 5.3 有限元方法

1. Thomas J.R. Hughes: "The Finite Element Method: Linear Static and Dynamic Finite Element Analysis", Dover Publications, 2000

2. O.C. Zienkiewicz, R.L. Taylor: "The Finite Element Method", Butterworth-Heinemann, 2000

### 5.4 共旋转有限元

1. M. Mueller, M. Gross: "Interactive Virtual Materials", Graphics Interface 2004

2. J. Barbic: "Exact Corotational Linear FEM Stiffness Matrix", Technical Report, USC, 2012

### 5.5 超弹性有限元

1. G. Irving, J. Teran, R. Fedkiw: "Invertible Finite Elements for Robust Simulation of Large Deformation", SCA 2004

2. J. Teran, E. Sifakis, G. Irving, R. Fedkiw: "Robust Quasistatic Finite Elements and Flesh Simulation", SIGGRAPH 2005

3. J. M. Solberg, R. E. Jones: "A Feature-Based Approach to Modeling Incompressible Flow", 2001

### 5.6 StVK有限元

1. D. L. James, D. K. Pai: "ArtDefo: Accurate Real Time Deformable Objects", SIGGRAPH 1999

2. J. Barbic, D. L. James: "Real-Time Subspace Integration for St. Venant-Kirchhoff Deformable Models", ACM TOG 2005

### 5.7 正交各向异性材料

1. Yijing Li, Jernej Barbic: "Stable Orthotropic Materials", Symposium on Computer Animation 2014

### 5.8 模型降阶

1. Jernej Barbic, Doug L. James: "Real-Time Subspace Integration for St. Venant-Kirchhoff Deformable Models", ACM TOG 2005

2. Jernej Barbic: "Real-Time Reduced Large-Deformation Models and Distributed Contact for Computer Graphics and Haptics", PhD Thesis, CMU, 2007

---

## 附录

### A. 符号说明

| 符号 | 含义 | 单位 |
|------|------|------|
| φ(x) | 符号距离场 | m |
| d(x) | 距离函数 | m |
| s | 符号 | - |
| Γ | 物体边界曲面 | - |
| Ω | 物体域 | m³ |
| u | 位移向量 | m |
| ε | 应变张量 | - |
| σ | 应力张量 | Pa |
| F | 变形梯度 | - |
| E | 杨氏模量 | Pa |
| ν | 泊松比 | - |
| μ | 剪切模量 | Pa |
| K | 体积模量 | Pa |
| ρ | 密度 | kg/m³ |
| M | 质量矩阵 | kg |
| K | 刚度矩阵 | N/m |
| C | 阻尼矩阵 | N·s/m |
| f | 力向量 | N |
| t | 时间 | s |
| Δt | 时间步长 | s |

### B. 代码示例

#### B.1 创建距离场

```cpp
#include <vegafem/distanceFieldCreator.h>
#include <vegafem/objMesh.h>

using namespace vegafem;

// 加载网格
ObjMesh * mesh = new ObjMesh("model.obj");

// 创建距离场创建器
DistanceFieldCreator creator;
creator.setAutomaticBoundingBox(true, 1.5);

// 计算有符号距离场
DistanceField * sdf = creator.ComputeDistanceField(
    256, 256, 256,  // 分辨率
    1,              // 有符号
    DistanceFieldCreator::POLYGONSOUP,
    0.01,           // sigma
    1,              // subtractSigma
    false,          // computeVoronoiDiagram
    15,             // maxTriCount
    10,             // maxDepth
    0,              // closestPointFlag
    NULL            // precomputedUnsignedFieldFilename
);

// 查询距离
Vec3d pos(0.5, 0.5, 0.5);
float distance = sdf->distance(pos);
Vec3d gradient = sdf->gradient(pos);

// 保存距离场
sdf->save("distanceField.bin", false);

// 清理
delete sdf;
delete mesh;
```

#### B.2 创建FEM模型

```cpp
#include <vegafem/corotationalLinearFEM.h>
#include <vegafem/tetMesh.h>

using namespace vegafem;

// 加载四面体网格
TetMesh * mesh = new TetMesh("model.tet");

// 创建共旋转线性FEM模型
CorotationalLinearFEM * fem = new CorotationalLinearFEM(mesh);

// 获取刚度矩阵拓扑
SparseMatrix * stiffnessMatrixTopology;
fem->GetStiffnessMatrixTopology(&stiffnessMatrixTopology);

// 分配位移和力向量
int numVertices = mesh->getNumVertices();
double * u = new double[3 * numVertices];
double * f = new double[3 * numVertices];
memset(u, 0, sizeof(double) * 3 * numVertices);

// 计算能量、力和刚度矩阵
double energy = 0.0;
SparseMatrix * stiffnessMatrix = new SparseMatrix(*stiffnessMatrixTopology);

fem->ComputeEnergyAndForceAndStiffnessMatrix(
    u,              // 位移
    &energy,        // 能量
    f,              // 内力
    stiffnessMatrix, // 刚度矩阵
    1               // warp模式
);

printf("Strain energy: %f J\n", energy);

// 清理
delete stiffnessMatrix;
delete stiffnessMatrixTopology;
delete[] u;
delete[] f;
delete fem;
delete mesh;
```

#### B.3 接触检测与力计算

```cpp
#include <vegafem/distanceField.h>

using namespace vegafem;

// 参数
double penaltyStiffness = 1e5;
double frictionCoeff = 0.3;

// 检测碰撞并计算接触力
for (int i = 0; i < numVertices; i++) {
    Vec3d pos = currentPos[i];
    
    // 查询距离
    float d = sdf->distance(pos);
    
    if (d < 0) {
        // 穿透，计算接触力
        Vec3d n = sdf->gradient(pos);
        n.normalize();
        
        // 法向接触力
        Vec3d f_normal = penaltyStiffness * d * n;
        
        // 切向摩擦力
        Vec3d v = velocity[i];
        Vec3d v_t = v - (v · n) * n;
        
        Vec3d f_friction(0, 0, 0);
        if (v_t.length() > 1e-6) {
            Vec3d t = v_t / v_t.length();
            f_friction = -frictionCoeff * f_normal.length() * t;
        }
        
        // 总接触力
        Vec3d f_contact = f_normal + f_friction;
        
        // 添加到力向量
        f[3*i] += f_contact[0];
        f[3*i+1] += f_contact[1];
        f[3*i+2] += f_contact[2];
    }
}
```

### C. 常见问题

#### C.1 距离场计算失败

**问题**：计算有符号距离场时返回错误。

**原因**：输入网格不是封闭流形网格。

**解决**：
1. 使用 [SignedDistanceFieldFromPolygonSoup](file:///e:/workspace/VegaFEM/libraries/distanceField/signedDistanceFieldFromPolygonSoup.h) 类
2. 设置合适的 sigma 参数
3. 检查网格是否封闭

#### C.2 接触力不稳定

**问题**：接触力振荡或发散。

**原因**：罚参数设置不当。

**解决**：
1. 减小罚刚度
2. 使用隐式时间积分
3. 增加阻尼

#### C.3 单元翻转

**问题**：大变形时单元翻转。

**原因**：变形超过材料承受能力。

**解决**：
1. 使用 [IsotropicHyperelasticFEM](file:///e:/workspace/VegaFEM/libraries/isotropicHyperelasticFEM/isotropicHyperelasticFEM.h) 并设置 inversionThreshold
2. 减小时间步长
3. 增加材料刚度

#### C.4 性能问题

**问题**：仿真速度太慢。

**原因**：网格过密或算法效率低。

**解决**：
1. 使用模型降阶
2. 降低距离场分辨率
3. 启用并行计算
4. 使用稀疏矩阵

---

**文档版本**：1.0  
**最后更新**：2026-01-10  
**作者**：VegaFEM开发团队
